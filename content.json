{"meta":{"title":"DREAMER","subtitle":"Dreamer Blog","description":"关注一线网络技术","author":"Dreamer","url":"https://dreamer1103.github.io","root":"/"},"pages":[{"title":"PyChina","date":"2020-03-16T02:14:19.285Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"PyChina/index.html","permalink":"https://dreamer1103.github.io/PyChina/index.html","excerpt":"","text":""},{"title":"Collect","date":"2019-01-08T14:39:26.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"Collect/index.html","permalink":"https://dreamer1103.github.io/Collect/index.html","excerpt":"","text":"Tools小记 description tools Link 截屏工具 Snipaste https://zh.snipaste.com/ 录屏工具 oCam https://download.cnet.com/oCam/3000-13633_4-75758209.html 清理工具 CCleaner https://www.ccleaner.com/ccleaner 远程连接工具 Xshell https://www.netsarang.com/products/xsh_overview.html 搜索利器 Everything http://www.voidtools.com/ Markdown编辑器 typora https://www.typora.io/ Shadowsocks-Qt5 影梭 https://github.com/shadowsocks/shadowsocks-qt5 windows数字权利激活工具 CMWTAT_Digital_Edition https://tgsan.github.io/CMWTAT_Digital_Edition/ 镜像制作 WPE工具箱 http://udsdown.xyz/109.html 镜像制作 refus https://rufus.ie/ 启动项管理 EasyUEFI https://www.easyuefi.com/index-cn.html 压缩工具 7-zip https://www.7-zip.org/ 优质文章小记用GDB调试程序 https://blog.csdn.net/haoel/article/details/2879 https://blog.csdn.net/haoel/article/details/2880?utm_source=blogxgwz2 https://blog.csdn.net/haoel/article/details/2881 https://blog.csdn.net/haoel/article/details/2882 https://blog.csdn.net/haoel/article/details/2883/ https://blog.csdn.net/haoel/article/details/2884 https://blog.csdn.net/haoel/article/details/2885/ https://coolshell.cn/articles/3643.html 跟我一起写Makefile https://blog.csdn.net/haoel/article/details/2886 https://blog.csdn.net/haoel/article/details/2887/ https://blog.csdn.net/haoel/article/details/2888 https://blog.csdn.net/haoel/article/details/2889/ https://blog.csdn.net/haoel/article/details/2890 https://blog.csdn.net/haoel/article/details/2891 https://blog.csdn.net/haoel/article/details/2892 https://blog.csdn.net/haoel/article/details/2893/ https://blog.csdn.net/haoel/article/details/2894 https://blog.csdn.net/haoel/article/details/2895 https://blog.csdn.net/haoel/article/details/2896 https://blog.csdn.net/haoel/article/details/2897 https://blog.csdn.net/haoel/article/details/2898 https://blog.csdn.net/haoel/article/details/2899"},{"title":"About","date":"2018-09-20T05:37:03.000Z","updated":"2021-12-09T13:32:13.490Z","comments":true,"path":"about/index.html","permalink":"https://dreamer1103.github.io/about/index.html","excerpt":"","text":"聊一聊我是谁 极客爱好者Dreamer 目前在学习 Web 开发 Pythonista、Rustacean 关于博客 搭建这个博客的目的是为了放一些自己平时的学习笔记 我发现我搭个博客学了很多花里胡哨的东西😂 emmm。。。有些话想到再说。 听歌可以戳下面，猛戳，别客气o(*≧▽≦)ツ┏━┓"},{"title":"所有分类","date":"2020-03-13T04:59:08.689Z","updated":"2020-03-13T04:59:08.689Z","comments":true,"path":"categories/index.html","permalink":"https://dreamer1103.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-06-04T05:07:04.177Z","updated":"2020-03-13T08:13:07.152Z","comments":true,"path":"friends/index.html","permalink":"https://dreamer1103.github.io/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： xaoxuu’s blog头像： https://img.vim-cn.com/76/c339fd7092750f472da9ad17bd7c0081a1f0e2.jpg网址： https://xaoxuu.com/blog/标签： iOS"},{"title":"所有标签","date":"2020-03-13T05:24:51.042Z","updated":"2020-03-13T05:24:51.042Z","comments":true,"path":"tags/index.html","permalink":"https://dreamer1103.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Centos7.7安装bind-9.11.4","slug":"centos7.7安装bind-9.11.4","date":"2020-04-22T03:29:17.000Z","updated":"2020-04-22T03:51:24.760Z","comments":true,"path":"2020/04/22/centos7.7安装bind-9.11.4/","link":"","permalink":"https://dreamer1103.github.io/2020/04/22/centos7.7%E5%AE%89%E8%A3%85bind-9.11.4/","excerpt":"","text":"一.基础环境准备1.1设置主机名 1hostnamectl set-hostname jmds1-11.host.com #jmds1-11生产方式常用地点命名主机方式 1.2关闭防护墙和selinux 1234systemctl stop firewalldsystemctl disable firewalldsetenforce 0sed –i ‘s/SELINUX=enforcing/SELINUX=disabled/g’ /etc/selinux/config 1.3设置网卡 12345678910cat /etc/sysconfig/network-scripts/ifcfg-eth0 TYPE=EthernetBOOTPROTO=noneNAME=eth0DEVICE=eth0ONBOOT=yesIPADDR=172.16.1.11NETMASK=255.255.255.0GATEWAY=172.16.1.254DNS1=172.16.1.254 1.4设置yum源和epel源 1234wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repowget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repoyum clean allyum makecache 1.5安装常用工具 1yum install wget net-tools telnet tree nmap sysstat lrzsz dos2unix bind-utils -y 二.安装bind服务2.1安装bind-9.11.4服务 1yum install bind -y 2.2配置bind 9 123456789vi /etc/named.conf #配置主文件named.conflisten-on port 53 &#123; 172.16.1.11; &#125;; allow-query &#123; any; &#125;;forwarders &#123; 172.16.1.254; &#125;; #下一级DNSrecursion yes;dnssec-enable no;dnssec-validation no##############named-checkconf #检查named.conf文件语法 123456789101112vi /etc/named.rfc1912.zones #配置域文件也可以在主文件里配置一样的zone \"host.com\" IN &#123; #主机域 type master; file \"host.com.zone\"; allow-update &#123; 10.4.7.11; &#125;;&#125;;zone \"md.com\" IN &#123; #业务域MD市场部 type master; file \"od.com.zone\"; allow-update &#123; 10.4.7.11; &#125;;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738cp -p /var/named/named.localhost /var/named/host.com.zone #模板拷贝两个域加-p保持属性cp -p /var/named/named.localhost /var/named/md.com.zonevim /var/named/host.com.zone$TTL 1D@ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS @ A 172.16.1.11 AAAA ::1jmds1-11 A 172.16.1.11jmds1-12 A 172.16.1.12jmds1-21 A 172.16.1.21jmds1-22 A 172.16.1.22jmds1-200 A 172.16.1.200vim /var/named/md.com.zone$TTL 1D@ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS @ A 172.16.1.11 AAAA ::1named-checkconf #检查主配置文件语法named-checkzone zone /var/named/host.com.zone #检查域配置文件语法zone zone/IN: loaded serial 0OKnamed-checkzone zone /var/named/md.com.zonezone zone/IN: loaded serial 0OK 2.3检查配置并启动bind 9 1234567891011systemctl start namednetstat -lntup|grep nameddig -t A hdss7-11.host.com @10.4.7.11 +shortping jmds1-11PING jmds1-11.host.com (172.16.1.11) 56(84) bytes of data.64 bytes from jmds1-11.host.com (172.16.1.11): icmp_seq=1 ttl=64 time=0.006 ms###如果systemctl start named启动不了报错，直接用 named -u named 可以启动，如果要习惯 systemctl restart named.service启动的话，注释掉下面文件一行vim /usr/lib/systemd/system/named.service#ExecStartPre#注释ExecStartPre 不检查 zone 2.4配置DNS客户端 12345678vim /etc/sysconfig/network-scripts/ifcfg-eth0DNS1=172.16.1.11##########vim /etc/resolv.confsearch host.comnameserver 172.16.1.11##########systemctl restart network 完成配置！！！","categories":[{"name":"linux","slug":"linux","permalink":"https://dreamer1103.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://dreamer1103.github.io/tags/linux/"},{"name":"k8s","slug":"k8s","permalink":"https://dreamer1103.github.io/tags/k8s/"}]},{"title":"Centos7 修改网卡为eth0","slug":"Centos7 修改网卡为eth0","date":"2020-04-21T03:29:17.000Z","updated":"2020-04-22T03:16:58.939Z","comments":true,"path":"2020/04/21/Centos7 修改网卡为eth0/","link":"","permalink":"https://dreamer1103.github.io/2020/04/21/Centos7%20%E4%BF%AE%E6%94%B9%E7%BD%91%E5%8D%A1%E4%B8%BAeth0/","excerpt":"默认centos7安装不设置内核版本，会影响网卡的名称。所以为了我们统一管理我们需要将网卡名称修改为eth开头 第一步查看服务器版本12[root@localhost ~]# cat &#x2F;etc&#x2F;redhat-releaseCentOS Linux release 7.6.1810 (Core) 第二步查看当前网卡名称我们可以看到当前网卡名称都是en0开头的，不方便我们集中管理","text":"默认centos7安装不设置内核版本，会影响网卡的名称。所以为了我们统一管理我们需要将网卡名称修改为eth开头 第一步查看服务器版本12[root@localhost ~]# cat &#x2F;etc&#x2F;redhat-releaseCentOS Linux release 7.6.1810 (Core) 第二步查看当前网卡名称我们可以看到当前网卡名称都是en0开头的，不方便我们集中管理 12345678910111213141516171819[root@localhost ~]# ip a1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1&#x2F;8 scope host lo valid_lft forever preferred_lft forever inet6 ::1&#x2F;128 scope host valid_lft forever preferred_lft forever2: eno1: mtu 1500 qdisc mq state DOWN group default qlen 1000 link&#x2F;ether f4:1d:6b:86:8a:09 brd ff:ff:ff:ff:ff:ff3: eno2: mtu 1500 qdisc mq state DOWN group default qlen 1000 link&#x2F;ether f4:1d:6b:86:8a:0a brd ff:ff:ff:ff:ff:ff4: eno3: mtu 1500 qdisc mq state UP group default qlen 1000 link&#x2F;ether f4:1d:6b:86:8a:0b brd ff:ff:ff:ff:ff:ff inet 10.4.81.93&#x2F;24 brd 10.4.81.255 scope global noprefixroute eno3 valid_lft forever preferred_lft forever inet6 fe80::687f:25f8:b435:887b&#x2F;64 scope link noprefixroute valid_lft forever preferred_lft forever5: eno4: mtu 1500 qdisc mq state DOWN group default qlen 1000 link&#x2F;ether f4:1d:6b:86:8a:0c brd ff:ff:ff:ff:ff:ff 第三步进入网卡配置文件将所有的文件mv 更换名称 1234567891011[root@localhost ~]# cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;[root@localhost network-scripts]# lsifcfg-eno1 ifcfg-lo ifdown-ippp ifdown-ppp ifdown-TeamPort ifup-bnep ifup-isdn ifup-ppp ifup-TeamPort network-functionsifcfg-eno2 ifdown ifdown-ipv6 ifdown-routes ifdown-tunnel ifup-eth ifup-plip ifup-routes ifup-tunnel network-functions-ipv6ifcfg-eno3 ifdown-bnep ifdown-isdn ifdown-sit ifup ifup-ippp ifup-plusb ifup-sit ifup-wirelessifcfg-eno4 ifdown-eth ifdown-post ifdown-Team ifup-aliases ifup-ipv6 ifup-post ifup-Team init.ipv6-global[root@localhost network-scripts]#[root@localhost network-scripts]# mv ifcfg-eno1 ifcfg-eth0[root@localhost network-scripts]# mv ifcfg-eno2 ifcfg-eth1[root@localhost network-scripts]# mv ifcfg-eno3 ifcfg-eth2[root@localhost network-scripts]# mv ifcfg-eno4 ifcfg-eth3 第四步修改网卡信息 需要修改的主要几点 1.NAME 2.DEVICE 3.BOOTPROTO [dhcp or static or none]none和static需要在输入ip地址 4.添加HWADDR 默认网卡没有mac地址，需要添加mac地址 第五步修改内核参数1[root@localhost network-scripts]# vi &#x2F;etc&#x2F;sysconfig&#x2F;grub 在倒数第二行quiet前面添加net.ifnames=0 biosdevname=0 我们还可以在装系统的时候配置 光标移动到Install CentOS上，按tab键 输入net.ifnames=0 biosdevname=0 回车 第六步生成启动菜单1234567[root@localhost network-scripts]# grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfgGenerating grub configuration file ...Found linux image: &#x2F;boot&#x2F;vmlinuz-3.10.0-957.el7.x86_64Found initrd image: &#x2F;boot&#x2F;initramfs-3.10.0-957.el7.x86_64.imgFound linux image: &#x2F;boot&#x2F;vmlinuz-0-rescue-f9f84382fb844c0a84e9ee9b2a2906b5Found initrd image: &#x2F;boot&#x2F;initramfs-0-rescue-f9f84382fb844c0a84e9ee9b2a2906b5.imgdone 第七步验证是否修改成功12[root@localhost ~]# reboot #重启生效centos7默认不支持ifconfig,如果需要ifconfig请yum install net-t 修改完毕！","categories":[{"name":"linux","slug":"linux","permalink":"https://dreamer1103.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://dreamer1103.github.io/tags/linux/"}]},{"title":"使用 mypy 做 type check","slug":"使用-mypy-做type-check","date":"2020-03-06T03:29:17.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2020/03/06/使用-mypy-做type-check/","link":"","permalink":"https://dreamer1103.github.io/2020/03/06/%E4%BD%BF%E7%94%A8-mypy-%E5%81%9Atype-check/","excerpt":"前言完残！😂，最近看之前写的 Python 代码老得琢磨这比变量的类型是啥（Python 无类型系统xxx），不愧是我写的！ 看段之前写的实现迭代器模式的代码：","text":"前言完残！😂，最近看之前写的 Python 代码老得琢磨这比变量的类型是啥（Python 无类型系统xxx），不愧是我写的！ 看段之前写的实现迭代器模式的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 抽象迭代器类class Iterator(object): def hasNext(): pass def next(): pass# 抽象聚集类class Aggregate(object): def iterator(): passclass BookShelf(Aggregate): def __init__(self): self._books = [] self._last = 0 def getBookAt(self, index): return self._books[index] def appendBook(self, book): self._books.append(book) self._last = self._last + 1 def getLength(self): return self._last def iterator(self): return BookShelfIterator(self)class BookShelfIterator(Iterator): def __init__(self, bookShelf): self._bookShelf = bookShelf self._index = 0 def hasNext(self): if self._index &lt; self._bookShelf.getLength(): return True else: return False def next(self): book = self._bookShelf.getBookAt(self._index) self._index = self._index + 1 return bookclass Book(): def __init__(self, name): self._name = name def getName(self): return self._nameif __name__ == \"__main__\": bookShelf = BookShelf() bookShelf.appendBook(Book(\"A\")) bookShelf.appendBook(Book(\"B\")) bookShelf.appendBook(Book(\"C\")) bookShelf.appendBook(Book(\"D\")) it = bookShelf.iterator() while it.hasNext(): book = it.next() print(book.getName()) 有一丢丢难读（不通读的话，会乱猜某变量类型），回想之前在 PyCon China 2019 的大会资聊曾看到过类型检查相关的演讲主题，回顾下演讲视频。水一波，写篇文章了解下 Python 标准(PEP 3107 &amp; PEP 484 )支持的 mypy。 类型系统：编译期的类型推导检查规则，类型系统属于一种轻量级的形式化方法（一种数学方法） 使用-mypy1234# 安装 mypypip install mypy# 使用 mypy 做类型检查mypy module_name.py 以下使用方式适用于 Python 3.6 及以上的版本。值得注意：mypy 默认的推导类型不可为 None 变量的类型注释12345678integer: int = 1string: str = \"ShanSan\"err_str: str = 1 # error: Incompatible types in assignmentchild: bool = True# mypy 默认的推导类型不可为 Nonenone: int - None # error: Invalid type comment or annotationprint(integer, string) 内建类型关于更多 mypy 的类型系统内建的类型可参考：https://mypy.readthedocs.io/en/stable/builtin_types.html 123456789101112131415161718192021from typing import Dict, Tuple, Optional, Iterable, Union# 对于映射(Map)数据结构，需要指定 key 和 value 的类型x: Dict[str, float] = &#123;'field': 2.0&#125;# Tuple 需要指定所有元素的类型x: Tuple[int, str, float] = (3, \"yes\", 7.5)# error: Incompatible types in assignment (expression has type \"Tuple[int, str, float, int]\", variable has type \"Tuple[int, str, float]\")y: Tuple[int, str, float] = (3, \"yes\", 7.5, 11)op: Optional[str] = None # 可为 str 或 None# 泛用可迭代对象l: Iterable = [1]t: Iterable = (1, 2)d: Iterable = &#123;1: 1&#125;# 可为 str 或 intstr_int1: Union[str, int] = 1str_int2: Union[str, int] = \"ss\"str_int3: Union[str, int] = None # error 函数注解12345678910111213141516171819from typing import NoReturndef f1() -&gt; None: passdef f2() -&gt; NoReturn: # 无返回值 passdef plus(num1: int, num2: int) -&gt; int: return num1 + num2# 带默认值def plus_default(num1: int, num2: int = 3) -&gt; int: return num1 + num2# 容器的参数类型def container_param(names: List[str]) -&gt; None: for name in names: print(name) 类成员注解123456789101112131415class MyClass: attr: int # 带默认值的实例变量 charge_percent: int = 100 # 没有任何返回值应该注解为 None def __init__(self) -&gt; None: pass # 忽略对 self 类型的注解 def my_method(self, num: int, str1: str) -&gt; str: return num * str1# 支持自定义类型的注解x: MyClass = MyClass() 结尾OK， 差不多了，对之前的迭代器模式的代码改造一波 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from typing import List, Iterable# 抽象迭代器类class Iterator(object): def hasNext(self): pass def next(self): pass# 抽象聚集类class Aggregate(object): def iterator(self): passclass BookShelf(Aggregate): def __init__(self) -&gt; None: self._books: List[Book] = [] self._last: int = 0 def getBookAt(self, index: int) -&gt; Book: return self._books[index] def appendBook(self, book: Book) -&gt; None: self._books.append(book) self._last = self._last + 1 def getLength(self) -&gt; int: return self._last def iterator(self) -&gt; BookShelfIterator: return BookShelfIterator(self)class BookShelfIterator(Iterator): def __init__(self, bookShelf) -&gt; None: self._bookShelf: BookShelf = bookShelf self._index: int = 0 def hasNext(self) -&gt; bool: if self._index &lt; self._bookShelf.getLength(): return True else: return False def next(self) -&gt; Book: book: Book = self._bookShelf.getBookAt(self._index) self._index = self._index + 1 return bookclass Book(): def __init__(self, name) -&gt; None: self._name: str = name def getName(self) -&gt; str: return self._nameif __name__ == \"__main__\": bookShelf: BookShelf = BookShelf() bookShelf.appendBook(Book(\"A\")) bookShelf.appendBook(Book(\"B\")) bookShelf.appendBook(Book(\"C\")) bookShelf.appendBook(Book(\"D\")) it: Iterator = bookShelf.iterator() while it.hasNext(): book: Book = it.next() print(book.getName()) emmm, 舒服了一丢丢/(ㄒoㄒ)/~~ 参考 https://github.com/python/mypy PyCon China 2019 成都分会场-刘知杭-静态类型的 Python, video🔗 PyCon China 2019 北京分会场-依云-类型检查拯救粗心开发者, video🔗 Type hints cheat sheet (Python 3)","categories":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/tags/Python/"},{"name":"静态类型检查","slug":"静态类型检查","permalink":"https://dreamer1103.github.io/tags/%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/"}]},{"title":"洞悉技术的本质-Git内部原理探索","slug":"Git内部原理探索","date":"2020-02-02T16:49:18.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2020/02/03/Git内部原理探索/","link":"","permalink":"https://dreamer1103.github.io/2020/02/03/Git%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E6%8E%A2%E7%B4%A2/","excerpt":"前言洞悉技术的本质，可以让我们在层出不穷的框架面前仍能泰然处之。用了那么久的 Git，不懂点内部原理，那可不行！懂点原理可以让我们遇到问题的时候能够更好更快的理清解决问题的思路。 要真正读懂本文可能需要以下基础： 有 Git 使用经验 对 Git 的三个分区有所了解 熟悉常用的 Linux 命令 对经典哈希算法有一定的了解，比如SHA-1、SHA-256、MD5等 在开始之前，让我们先抛出几个问题，然后一一解决、回答它们 .git版本库里的文件/目录是干什么的? Git是如何存储文件信息的？ 当我们执行git add、git commit时，Git背后做了什么？ Git分支的本质是什么?","text":"前言洞悉技术的本质，可以让我们在层出不穷的框架面前仍能泰然处之。用了那么久的 Git，不懂点内部原理，那可不行！懂点原理可以让我们遇到问题的时候能够更好更快的理清解决问题的思路。 要真正读懂本文可能需要以下基础： 有 Git 使用经验 对 Git 的三个分区有所了解 熟悉常用的 Linux 命令 对经典哈希算法有一定的了解，比如SHA-1、SHA-256、MD5等 在开始之前，让我们先抛出几个问题，然后一一解决、回答它们 .git版本库里的文件/目录是干什么的? Git是如何存储文件信息的？ 当我们执行git add、git commit时，Git背后做了什么？ Git分支的本质是什么? Git分区在真正开始之前，让我们先回顾下Git的三个分区（Workspace、Index / Stage、git repository） 工作区（Workspace）：此处进行代码文件的编辑 索引或称暂存区（Index / Stage）：存储文件状态信息，进行commit前会对此时的文件状态作快照（Snapshot） Git版本库（git repository）：由Git Object持久记录每一次commit的快照和链式结构的commit变更历史 先看下从《Got Git》和网络上搬来的Git分区工作原理图和待remote的工作流再次感性回顾下之前使用Git自己时怎么操作的 相信看了这些，会对Git有新的认知，让我们正式开始🎉！ .git版本库里的文件/目录是干什么的让我们通过一个从GitHub clone下来的一个实际项目的版本库来看下这些文件/目录，clone下来的repository 12345678910111213$ git clone https://github.com/yeshan333/Explore-Git$ ls -F1configdescriptionHEADhooks/indexinfo/logs/objects/packed-refsrefs/ 挑几个重要文件/目录的做下解释 HEAD文件：用于存放当前所在分支的引用，这个引用是个符号引用（symbolic reference） index文件：二进制文件，它就是暂存区（Stage Area）。它是一个目录树，记录了文件的时间戳、文件长度、SHA-1等 refs目录：基本所有的引用（references）文件都存放在这里，引用文件中的内容为SHA-1值，一般是commit object的SHA-1值 objects目录：用于存放数据的所有 Git Object均存放在这个目录下，每个 Git Object 对应一个目录，object对应的SHA-1值的前 2 位为目录名，后 38 位为文件名 抱着一些初步的认知，我们继续解决后面几个问题，加深对.git版本库内文件的理解 Git是如何存储文件信息的要知道Git如何存储信息，我们需要了解一下常见的Git对象，Git就是通过这些对象存储文件信息的。Git Object是Git存储文件信息的最小单元，如下为几种常见的Git Object以及它们的作用，它们一般是不可变的（immutable），这些对象使用40位的SHA-1值进行标识。 blob：用于存储文件内容，Git保存文件的时候不会保存文件名 tree object：当前目录结构的一个快照（Snapshot），它存储了一条或多条树记录（tree entries），每条记录含有一个指向数据对象（blob）或子树对象（子树木对象可理解为子目录）的SHA-1指针以及相应的文件模式、类型、文件名，用于表示内容之间的目录层次关系 commit object：存储顶层tree object的SHA-1值、作者/提交者信息+时间戳以及提交注释，如果有父commit object，还会保存有这个commit object对应的SHA-1值。对于merge commit可能会有多个父commit object tag object：用于标记commit object。关于tag object 让我们通过一个实际的版本库了解下这些对象，使用git log查看这个版本库详尽的历史提交记录 123456789101112131415$ git log --pretty=rawcommit ee8a0dbc0c6fe89e6ff39b16c77543e8e2c6475btree fb12b3e52ce18ce281bfc2b11a5e4350c2d10358parent 7b94dcbe89c9534913854284b4af727a9a5dfc84author yeshan333 &lt;1329441308@qq.com&gt; 1580629391 +0800committer yeshan333 &lt;1329441308@qq.com&gt; 1580629391 +0800 final commitcommit 7b94dcbe89c9534913854284b4af727a9a5dfc84tree 8feb4afbab18e8d386413224a9e74f871c15a5caauthor yeshan333 &lt;1329441308@qq.com&gt; 1580629170 +0800committer GitHub &lt;noreply@github.com&gt; 1580629170 +0800 Initial commit Git提供了一把非常好用的瑞士军刀🔪给我们剖析这些对象，它是就是cat-file，通过-t参数可以查看object的类型，通过-p参数我们可以查看object存储的具体内容。查看信息时，我们需要使用到object对应的SHA-1值，可不必写完，从头开始的前几位不冲突即可。git cat-file 让我们通过它查看下SHA-1值ee8a0dbc0c6fe89e6ff39b16c77543e8e2c6475b对应的commit object的类型以及存放的内容。 12345678910$ git cat-file -t ee8acommit$ git cat-file -p ee8atree fb12b3e52ce18ce281bfc2b11a5e4350c2d10358parent 7b94dcbe89c9534913854284b4af727a9a5dfc84author yeshan333 &lt;1329441308@qq.com&gt; 1580629391 +0800committer yeshan333 &lt;1329441308@qq.com&gt; 1580629391 +0800final commit 让我们再查看下这个commit object（ee8a）存储的tree object（fb12）的信息 123456$ git cat-file -p fb12100644 blob 6116a7dd8f752dabff8730a46b46846b2d0a696b README.md040000 tree 41ed97c2adb97658107069582b6a27e474b4cc64 test$ git cat-file -t fb12tree 我们知道tree object存储了一条或多条树记录（tree entries），每条记录含有一个指向数据对象（blob）或子树对象（子树木对象可理解为子目录）的SHA-1指针以及相应的文件模式、类型、文件名。100644即为对应的文件模式，100644表示普通文本文件，040000表示目录文件。关于文件模式的一点疑问 让我们再看下tree object（fb12）存储的SHA-1指针（6116）对应的blob（6116）存放的内容 1234$ git cat-file -p 6116# Explore-Git$ git cat-file -t 6116blob Nice，很好的对应了之前对blob、tree object、commit object的描述。关于文件的大部分信息都存放在这些object中。 当我们执行git add、git commit时，Git背后做了什么解答这个问题，我们需要通过实践去一步步感受Git背后的操作。我们创建一个简单的例子感受下，我们需要时刻关注.git/objects这个目录 1234567891011$ mkdir demo$ cd demo$ git init # 初始化Git仓库$ find .git/objects -type f # 没有文件$ echo \"test\" &gt; test.txt$ mkdir hi$ cd hi$ echo \"Hello\" &gt; hello.txt$ cd ..$ find .git/objects -type f$ # 什么都没有 这里我们创建先了两个文件，test.txt、hello.txt，其中hello.txt文件放到了hi目录中，然后我们查看了.git/objects目录，没有文件。接下来就是重头戏了，我们要将当前目录的文件/目录（Linux一切皆文件）添加到暂存区（stage/index）。 1234$ git add .$ find .git/objects -type f.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4.git/objects/e9/65047ad7c57865823c7d992b1d046ea66edf78 我们可以看到，执行了git add之后生成了两个文件，让我们通过git cat-file看看这两个文件 12345678$ git cat-file -t 9daeblob$ git cat-file -p 9daetest # test.txt文件中的内容$ git cat-file -t e965blob$ git cat-file -p e965Hello # hi/hello.txt文件中的内容 哦，Git为我们生成了两个object，两个blob，存放的是test.txt、hello.txt的内容，让我们commit一下看看Git又做了什么 123456789101112131415161718192021222324$ find .git/objects -type f.git/objects/27/1c49aa4a2c8eb1b2ef503c19378aa6810fca1e.git/objects/2e/8ebea76975c98806e73c0b7aea6c40c58d427c.git/objects/8c/3c7fbcd903744b20fd7567a1fcefa99133b5bc.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4.git/objects/e9/65047ad7c57865823c7d992b1d046ea66edf78$ git cat-file -t 271ccommit$ git cat-file -t 2e8etree$ git cat-file -t 8c3ctree$$ git cat-file -p 271ctree 2e8ebea76975c98806e73c0b7aea6c40c58d427cauthor root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580651827 +0800committer root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580651827 +0800Hello Git$ git cat-file -p 8c3c100644 blob e965047ad7c57865823c7d992b1d046ea66edf78 hello.txt$ git cat-file -p 2e8e040000 tree 8c3c7fbcd903744b20fd7567a1fcefa99133b5bc hi100644 blob 9daeafb9864cf43055ae93beb0afd6c7d144bfa4 test.txt 哦，commit后Git为我们新创建了3个object，分别是根树对象tree object（2e8e）、子树对象tree object（8c3c）、commit object（271c）。现在一共有5个Git Object。这些object存放的内容符合我们在解答Git是如何存储文件信息的时对它们的表述。Git在add、commit后有条不紊的把它们组织了起来。tql👍 让我们看下此次提交的日志 1234567$ git log --pretty=rawcommit 271c49aa4a2c8eb1b2ef503c19378aa6810fca1etree 2e8ebea76975c98806e73c0b7aea6c40c58d427cauthor root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580651827 +0800committer root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580651827 +0800 Hello Git 问题来了，Git是如何组织这些object的❓令人兴奋的是Git在提供给我们这些顶层API去愉快使用的同时还提供了一些较为底层的API让我们能够更深入的了解它。接下来我们将通过部分底层的API来重现本次commit log的创建过程。主要用到的底层API如下： git hash-object：生成blob git update-index：对暂存区进行操作 git write-tree：根据当前暂存区（index）状态创建一个tree object git read-tree：将tree object读入暂存区 git commit-tree：创建commit object 重现步骤如下： 1、先初始化版本库，再为内容分别为test的test.txt、Hello的hello.txt创建两个blob，blob不存储文件名 1234567$ mkdir test$ cd testgit init$ echo 'test' | git hash-object -w --stdin9daeafb9864cf43055ae93beb0afd6c7d144bfa4$ echo 'Hello' | git hash-object -w --stdine965047ad7c57865823c7d992b1d046ea66edf78 2、使用git update-index -add将blob（e965）加入暂存区，使用--cacheinfo参数指定文件模式、SHA-1值、文件名（hello.txt） 1$ git update-index --add --cacheinfo 100644 e965047ad7c57865823c7d992b1d046ea66edf78 hello.txt 3、使用git write-tree将当前暂存区状态写入一个tree object（8c3c） 12$ git write-tree8c3c7fbcd903744b20fd7567a1fcefa99133b5bc 4、将hello.txt移出暂存区，将blob（9dae）加入暂存区（即将test.txt加入暂存区） 12$ git update-index --remove hello.txt$ git update-index --add --cacheinfo 100644 9daeafb9864cf43055ae93beb0afd6c7d144bfa4 test.txt 5、使用git read-tree将已有tree object作为子树对象加入暂存区，通过--prefix设置名称为hi 1$ git read-tree --prefix=hi 8c3c7fbcd903744b20fd7567a1fcefa99133b5bc 6、记录下当前暂存区状态到tree object 12$ git write-tree2e8ebea76975c98806e73c0b7aea6c40c58d427c 7、使用git commit-tree根据tree object的SHA-1值创建commit object 12$ echo 'Hello Git' | git commit-tree 2e8e2616a5b40ead79df23736f61b346080423f438fe 8、查看commit log，没多大毛病，收工🎉 1234567891011121314$ git log --pretty=raw 2616commit 2616a5b40ead79df23736f61b346080423f438fetree 2e8ebea76975c98806e73c0b7aea6c40c58d427cauthor root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580660050 +0800committer root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580660050 +0800 Hello Git$ git cat-file -p 2616tree 2e8ebea76975c98806e73c0b7aea6c40c58d427cauthor root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580660050 +0800committer root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580660050 +0800Hello Git 相信到了这里，已经对Git在我们git add、git commit时做了什么有了一定的了解。如果想了解Git Object对应的SHA-1值如何生成和如何复现并串联多个commit object形成一个提交历史链，可查看《Pro Git》的第十章第二小节或参看后面的参考资料。 Git分支的本质是什么Git分支的本质是指向某一系列提交之首的指针或引用。Git使用引用的一个好处就是我们不需要花心思去记那些Git Object长长的SHA-1值。引用是存放SHA-1值的文件，它们位于.git/refs目录中。Git提供了一个API让我们更新引用-update-ref，示例如下 123456789101112131415$ git update-ref refs/heads/master 2616 # 2616为之前浮现commit log创建的commit object的SHA-1值$ git logcommit 2616a5b40ead79df23736f61b346080423f438fe (HEAD -&gt; master)Author: root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt;Date: Mon Feb 3 00:14:10 2020 +0800 Hello Git$ git log mastercommit 2616a5b40ead79df23736f61b346080423f438fe (HEAD -&gt; master)Author: root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt;Date: Mon Feb 3 00:14:10 2020 +0800 Hello Git$ cat .git/refs/heads/master2616a5b40ead79df23736f61b346080423f438fe HEAD引用在介绍HEAD文件的时候我们说过它存放的是当前所在分支的引用，而且这个引用是个符号引用（symbolic reference）。那么什么是符号引用？它是一个指向其它引用的指针。我们可以查看之前clone下来的Explore-Git的HEAD文件 12$ cat .git/HEADref: refs/heads/master 当我们checkout到某个分支时，HEAD文件内容如下 123456$ git branch yeshan$ git checkout yeshanSwitched to branch 'yeshan'$ cat .git/HEADref: refs/heads/yeshan 至此，抛出的问题已解答完毕。 参考 Go Git：面向未来的代码平台，了解版本控制系统的发展和Git现存的问题，版本控制系统未来的走向 《Git权威指南》 - Git对象探秘 这才是真正的Git——Git内部原理揭秘！ 《Pro Git》- Basic Snapshotting Git对象模型 你知道 Git 是如何做版本控制的吗 图解Git GitHub Developer REST API Git Blobs 如何读取git-ls-tree输出的模式字段 常用Git命令清单","categories":[{"name":"Git","slug":"Git","permalink":"https://dreamer1103.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dreamer1103.github.io/tags/Git/"}]},{"title":"2019年总结","slug":"2019年总结","date":"2019-12-31T03:15:07.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/12/31/2019年总结/","link":"","permalink":"https://dreamer1103.github.io/2019/12/31/2019%E5%B9%B4%E6%80%BB%E7%BB%93/","excerpt":"","text":"前言扯🥚终于考完试了（昨天下午终结了最后一科-“万恶”的复变函数🎈🎉），可以摩擦下年终总结了，花点时间想下2019年我干了什么🎁。完了写不下去了（此时中午12点59分30秒。 忆往昔-xxx~2019这一年过得无比的充实，个人感觉高中的时候都没对自己这么狠过，我怕是上了个假的大学（忽然想起高三临近高考那段时间，别人在复习，而我却趴在桌面上在睡觉&lt;被“农药”毒害，趴了整个高三，挺对不起老师的，惭愧😥）。 以下开始略微总结下今年的操作、收获与遗憾。 阅读方面这一年看了很多的书，有技术方面的也有非技术方面的都有，我佛了，大三上一整个学期就没打过游戏，我都佩服我自己，ε=ε=ε=┏(゜ロ゜;)┛，略微罗列下： 没看完的，看了大部分，但是没再继续看 《Python密码学编程》 《Python从入门到实践》 《C++ Primer Plus》 《Python基础教程（第3版）》 《算法图解》 《啊哈！算法》 《HTTP权威指南》 《Flask Web开发：基于Python的Web应用开发实战》 《Flask 入门教程》 《Docker Deep Dive》 《Linux 就该这么学》 《How To Think Like A Computer Scientist》 可以说是看完了的 《Web全栈工程师的自我修养》 《Don’t Make Me Think》 《Growth: 全栈增长工程师指南》 《我的职业是前端工程师》 《RePractise》 …… 上图，emmm…我正在看的，希望开学前能看完大部分，又能“吹水”了，都是💪力量啊！ 小声bb，我入手了套《周易》，看了那么多还是菜（太卑微了，总有那么种好高骛远的感觉！！！斑驳 技术实践与交流这一年，我喜欢上了开源社区，我的第一个issue。很幸运能够偷偷的在图灵读者群QQ当个混子，知道了Manjusaka（璈叔，一直在听大佬出《捕蛇者说》播客，收获满满），通过大佬又知道了PyCon China。今年Python30周年，PyCon China 2019大佬云集，太香了，路费太贵没能去成，没能线下见诸位大佬（太苦bi了/(ㄒoㄒ)/~~，还好有PPT和视频放出来，现在仍在反复的看一些感兴趣的Topic的Slide和视频，又get✅到了学习的新姿势。 这一年我做的都是一些小玩意，太卑微了，不敢列出来。不得不说GitHub真香，一些开源项目拿来即可用，可以快速集成到自己弄得东西上（此处吐槽😒文档写的不好或者连文档都没有的，看的太难受了）。虽然整的都是一些花里胡哨的小东西，至少我看到了自己在成长，不亏，此处上我的GitHub小绿点： 再看下大佬的，我透，我就是didi，我整的还贼水。 GitHub还有一点特别香，通过follow各领域的大佬，我能了解到一些“骚”技术（emmm。。。，有些东西我还用上了，不愧是终极程序员社交网站。此处艾特一位友链小伙伴TRHX🔗，嘿嘿嘿，你star的大部分项目我都拿来耍过几下。 emmm，很幸运的认识了友链里诸位大佬，无聊的时候经常去lu你们的文章，收获还是蛮多的。 缺憾与期待这一年有点难 自学太痛苦了（线下找不到倾诉的伙伴，院里找不到“真正”有共同兴趣、爱好、热情的伙伴，大部分人只是说说而已，行动上的弱者），真希望有个dalao带带我（枯了 我吐，一年多没跳舞了，我居然抛弃了我曾经热爱的Breaking，虽然仍在看一些街舞文化相关的节目和比赛-&gt;《这！就是街舞》、《Red Bull BC One》，但我已经不再是个纯粹的B-Boy了 感觉自己没能真正的融入开源社区，并未参与多人优质开源项目的开发 撸了一下董老师的《爱澎湃2019年度Python榜单》，发现我知道的东西还是太少，看来我对Python的热爱没有那么纯粹，信息的来源不太行 看了下我的GitHub年度报告，看来得好好养生了 期待 新的一年，我又立下了一丢丢flag🚩，不知道下学期结束前能不能操作完(☆▽☆) 稳住，别浪，Hello World -&gt; Cloud Native, Meta Year 期待下一年能撸一个优秀的技术开源项目或者去为优秀的开源项目贡献代码 期待自己所待的科协在未来有真正强有力的积累，能发挥出“马太效应” 我似乎还没真正想明白我想要什么，不给力啊！ 新一年对自己的要求：不只是要做思想上的强者，更要做行动上的强者；多思考、多折腾、多更新。很喜欢的一句话：I hear and I forget. I see and I remember. I do and I understand.","categories":[{"name":"随笔","slug":"随笔","permalink":"https://dreamer1103.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://dreamer1103.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Nginx反向代理与正向代理","slug":"Nginx 反向代理与正向代理","date":"2019-12-25T06:45:23.000Z","updated":"2020-03-06T06:36:31.278Z","comments":true,"path":"2019/12/25/Nginx 反向代理与正向代理/","link":"","permalink":"https://dreamer1103.github.io/2019/12/25/Nginx%20%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/","excerpt":"","text":"Nginx 反向代理与正向代理代理分为正向代理和反向代理,本次就来演示一下Nginx配置正向代理和反向代理的场景。 顺便讲解一下正向代理和反向代理的区别正向代理和反向代理的区别 1Nginx 首先，我们需要知道什么是反向代理和正向代理区别 一、正向代理 正向代理简单的来说就是我们的代理服务器代替用户去请求后端节点 nginx正向代理代替工具还有goproxy 为什么要使用正向代理 用户无法直接访问服务器B （常见例子就是我们使用的Shadowsocks） Cache缓存作用 cache缓存技术和代理服务技术是紧密联系的（不只是正向代理使用cache缓存，反向代理同时也使用缓存）简单的来说就是用户A访问了代理服务器，那么代理服务器会将用户A的数据保存一段时间，如果该时间段呢用户B同时也访问了代理服务器，那么代理服务器将不会直接请求服务器B，而是直接将缓存直接返回给用户A 拦截访问 假设用户A和用户B都设置了代理服务器，用户A允许访问互联网，而用户B不允许防火互联网（这个代理服务器Z上做限制）这样用户A因为授权，可以通过代理服务器访问到服务器C，而用户B因为没有被代理服务器授权时，数据包会直接丢弃 隐藏访问者 我们可以看出服务器C并不知道访问自己的实际是用户A，因为代理服务器Z代替用户A去直接与服务器C进行交互，如果代理服务器Z完全被用户A控制（或不完全控制）会惯以肉鸡术语称呼 正向代理总结 正向代理是一个位于客户端和原始服务器(origin server)之前的服务器，为了从原始服务器获取内容，客户端向代理发送一个请求并指定目标，然后代理服务器向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器。（类似于我们的ss服务） 二、反向代理反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理发送普通请求，接着反向代理将判断向何处(后端节点)转交请求，并将获得的内容返回给客户端 通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器，并将本来要直接发送到Web服务器上的http请求发送到代理服务器中，当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式成为反向代理服务 透明代理 透明代理的意思是客户端根本不需要指定有代理服务器的存在，改变你的request fields(报文)，并会传送真实IP，注意加密的透明代理则属于匿名代理，意思是不用设置代理了。透明代理实践的例子就是很多公司所使用的行为管理软件 当用户A和用户B并不知道行为管理设备充当透明代理行为，用户A或者用户B向服务器A或者服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，并作为实际的请求方，向服务器A或者B发送请求，当接受信息回传，透明代理再根据自身的设置把允许的保存发回至用户A或B，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据 三、正向代理配置测试我们使用nginx代理上网为例子进行演示nginx正向代理 下载并安装nginx (正向代理不需要单独的模块) 我们使用2台服务器都进行如下操作 10.4.82.140 tomcat.i4t.com 为后端应用服务(域名为tomcat.i4t.com) 10.4.82.142 nginx.i4t.com 为代理服务器(域名为nginx.i4t.com) 请仔细阅读本段 首先我们代理服务器几乎不进行任何配置，只是一个普通的nginx代理，所有修改nginx的配置都是在代理服务器上添加 两台nginx默认配置如下 12345678910111213141516171819201.nginx版本没有太大要求wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.10.3.tar.gz#按照依赖包yum install -y gcc glibc gcc-c++ prce-devel openssl-devel pcre-develuseradd -s &#x2F;sbin&#x2F;nologin nginx -M tar xf nginx-1.10.3.tar.gz &amp;&amp; cd nginx-1.10.3#编译.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx-1.10.3 --user&#x3D;nginx --group&#x3D;nginx --with-http_ssl_module --with-http_stub_status_module检查&#x2F;usr&#x2F;loca&#x2F;nginx&#x2F;sbin&#x2F;nginx -t启动&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx查看服务器是否启动netstat -lntp|grep nginx tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 7058&#x2F;nginx: master 接下来是配置nginx代理 首先我们先配置2台nginx服务器 1.先配置nginx.i4t.com nginx信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445#配置10.4.82.142 后端服务器cat &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.confuser nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log logs&#x2F;access.log main; sendfile on; tcp_nopush on; keepalive_timeout 65; gzip on; server &#123; listen 80; server_name nginx.i4t.com; location &#x2F; &#123; root &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html; &#125; &#125;&#125;echo &quot;nginx.i4t.com&quot; &gt;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;index.html&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload 此时nginx.i4t.com域名访问如下 接下来配置后端服务器 12代理服务器默认配置10.4.82.140 以下是后端服务器默认配置 1234567891011121314151617181920212223242526272829303132333435user nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log logs&#x2F;access.log main; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name tomcat.i4t.com; location &#x2F; &#123; root html; index index.html index.htm; &#125; &#125;&#125; echo &quot; tomcat.i4t.com&quot; &gt;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;index.html &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload tomcat.i4t.com后端服务器的访问内容如下 接下来我们将tomcat.i4t.com 也就是10.4.82.140进行配置权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#只允许10.4.82.142访问cat &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.confuser nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log logs&#x2F;access.log main; sendfile on; tcp_nopush on; keepalive_timeout 65; gzip on; server &#123; listen 80; server_name tomcat.i4t.com; resolver 8.8.8.8; location &#x2F; &#123; proxy_pass $scheme:&#x2F;&#x2F;$host$request_uri; if ( $remote_addr !~* &quot;10.4.82.142&quot;) &#123; return 403; &#125; root &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html; &#125; &#125;&#125;#proxy_pass $scheme:&#x2F;&#x2F;$host（请求的域名）$request_uri; 域名后面参数#resolver DNS地址，可以不写 我们可以看到我们现在电脑已经无法访问tomcat.i4t.com，需要注意的是，我们只是修改了tomcat.i4t.com的代理，nginx.i4t.com依旧可以正常访问的 现在我们进行代理配置 windows配置如下 1IE--&gt;Internet选项--&gt;连接--&gt;局域网设置--&gt;代理服务器 mac设置如下 Linux 12export http_proxy&#x3D;http:&#x2F;&#x2F;10.4.82.142:80wget http:&#x2F;&#x2F;tomcat.i4t.com 这时候我们访问tomcat.i4t.com就是200，状态 四、反向代理配置测试安装和上面编译安装一样，没有特殊模块。只需要修改配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253cat &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.confuser www;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log logs&#x2F;access.log main; sendfile on; tcp_nopush on; keepalive_timeout 65; gzip on; server &#123; listen 80; server_name nginx.i4t.com; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;abcdocker; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125; upstream abcdocker &#123; server 10.4.82.140:8080; server 127.0.0.1:8080; &#125;&#125;#proxy_pass 代理节点，可以用ip+端口#upstream 后面写名称#server 后端节点名称 访问验证，我们访问nginx.i4t.com域名打开的是tomcat后端节点 请注意缓存（google浏览器缓存不是很好清理）","categories":[{"name":"nginx","slug":"nginx","permalink":"https://dreamer1103.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://dreamer1103.github.io/tags/nginx/"}],"author":"xiangyu1103"},{"title":"❤Thanksgiving❤","slug":"heart","date":"2019-11-28T15:50:56.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/11/28/heart/","link":"","permalink":"https://dreamer1103.github.io/2019/11/28/heart/","excerpt":"","text":"","categories":[{"name":"随笔","slug":"随笔","permalink":"https://dreamer1103.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://dreamer1103.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Serialization and Deserialization","slug":"Serialization-and-Deserialization","date":"2019-11-25T08:25:23.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/11/25/Serialization-and-Deserialization/","link":"","permalink":"https://dreamer1103.github.io/2019/11/25/Serialization-and-Deserialization/","excerpt":"序列化与反序列化 Serialization：Data Structure/Object –&gt; Binary StringDeserialization：Binary String –&gt; Data Structure/ObjectGoals：Cross-platform Communication、Persistent Storage and More Python中对象的序列化与反序列化pickle module pickle 仅可用于 Python，pickle所使用的数据流格式仅可用于 Pythonpickle 模块可以将复杂对象转换为字节流，也可以将字节流转换为具有相同内部结构的对象。可被pickling和unpickling的对象：https://docs.python.org/zh-cn/3/library/pickle.html#what-can-be-pickled-and-unpickled pickle提供了优秀的方法方便我们对对象进行pickling（封存）和unpickling（解封）","text":"序列化与反序列化 Serialization：Data Structure/Object –&gt; Binary StringDeserialization：Binary String –&gt; Data Structure/ObjectGoals：Cross-platform Communication、Persistent Storage and More Python中对象的序列化与反序列化pickle module pickle 仅可用于 Python，pickle所使用的数据流格式仅可用于 Pythonpickle 模块可以将复杂对象转换为字节流，也可以将字节流转换为具有相同内部结构的对象。可被pickling和unpickling的对象：https://docs.python.org/zh-cn/3/library/pickle.html#what-can-be-pickled-and-unpickled pickle提供了优秀的方法方便我们对对象进行pickling（封存）和unpickling（解封） 使用dumps和loads方法进行序列化和反序列化123456789101112131415&gt;&gt;&gt; import pickle&gt;&gt;&gt; person = dict(name='shan', age=20, sex=\"man\")&gt;&gt;&gt; pickle.dumps(person) # dumps方法会将obj序列化为bytes返回b'\\x80\\x03&#125;q\\x00(X\\x04\\x00\\x00\\x00nameq\\x01X\\x04\\x00\\x00\\x00shanq\\x02X\\x03\\x00\\x00\\x00ageq\\x03K\\x14X\\x03\\x00\\x00\\x00sexq\\x04X\\x03\\x00\\x00\\x00manq\\x05u.&gt;&gt;&gt;&gt;&gt;&gt; with open(\"dump.txt\",\"wb\") as f:... pickle.dump(person, f)...&gt;&gt;&gt; f = open(\"dump.txt\",\"rb\")&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;'name': 'shan', 'age': 20, 'sex': 'man'&#125;&gt;&gt;&gt; pickle.loads(pickle.dumps(d))&#123;'name': 'shan', 'age': 20, 'sex': 'man'&#125; https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump bytes对象是由单个字节组成的不可变序列 使用dump方法可将序列化的对象写入file obj load用于还原封存生成的bytes_object，loads方法用于还原从文件中读取的封存对象 json module 相比于pickle，json只能表示内置类型的子集，不能表示自定义的类json格式的文件的易读性更好Python json模块提供的API与pickle模块很相似 使用dumps和loads进行序列化和反序列化12345678&gt;&gt;&gt; import json&gt;&gt;&gt; person = dict(name='shan', age=20, sex=\"man\")&gt;&gt;&gt; json.dumps(person)'&#123;\"name\": \"shan\", \"age\": 20, \"sex\": \"man\"&#125;'&gt;&gt;&gt;&gt;&gt;&gt; json_str = json.dumps(person)&gt;&gt;&gt; json.loads(json_str)&#123;'name': 'shan', 'age': 20, 'sex': 'man'&#125; dumps方法会将obj转换为标准格式的JSON str并返回 loads方法可将包含JSON文档的str、bytes或者bytearray反序列化为Python对象 自定义对象的序列化与反序列化 对于自定义对象的序列化和反序列化操作需要我们实现专门的encoder和decoder需要用到dumps方法的default参数和loads方法的object_hook参数https://docs.python.org/3/library/json.html#json.loadshttps://docs.python.org/3/library/json.html#json.loads 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; import json&gt;&gt;&gt;&gt;&gt;&gt; class Student(object):... def __init__(self, name, age, score):... self.name = name... self.age = age... self.score = score...&gt;&gt;&gt; def student2dict(std):... return &#123;... 'name': std.name,... 'age': std.age,... 'score': std.score... &#125;...&gt;&gt;&gt; def dict2student(d):... return Student(d['name'], d['age'], d['score'])...&gt;&gt;&gt; s = Student('Bob', 20, 88)&gt;&gt;&gt; print(json.dumps(s, default=student2dict))&#123;\"name\": \"Bob\", \"age\": 20, \"score\": 88&#125;&gt;&gt;&gt; json_str = json.dumps(s, default=student2dict)&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))&lt;__main__.Student object at 0x000001B101675198&gt;&gt;&gt;&gt; json.loads(json_str, object_hook=dict2student)&lt;__main__.Student object at 0x000001B101675128&gt;&gt;&gt;&gt; old = json.loads(json_str, object_hook=dict2student)&gt;&gt;&gt; old.name'Bob' third-party module：marshmallow marshmallow is an ORM/ODM/framework-agnostic library for converting complex datatypes, such as objects, to and from native Python datatypes. 1234567891011121314151617181920212223&gt;&gt;&gt; import datetime as dt&gt;&gt;&gt; import marshmallow&gt;&gt;&gt; from dataclasses import dataclass&gt;&gt;&gt;&gt;&gt;&gt; from marshmallow import Schema, fields&gt;&gt;&gt;&gt;&gt;&gt; @dataclass... class Album:... title: str... release_date: dt.date...&gt;&gt;&gt; class AlbumSchema(Schema):... title = fields.Str()... release_date = fields.Date()...&gt;&gt;&gt; album = Album(\"Seven Innovation Base\", dt.date(2019, 11, 23))&gt;&gt;&gt; schema = AlbumSchema()&gt;&gt;&gt; data = schema.dump(album) # obj -&gt; dict&gt;&gt;&gt; data&#123;'title': 'Seven Innovation Base', 'release_date': '2019-11-23'&#125;&gt;&gt;&gt; data_str = schema.dumps(album) # obj -&gt; str&gt;&gt;&gt; data_str'&#123;\"title\": \"Seven Innovation Base\", \"release_date\": \"2019-11-23\"&#125;' 使用 marshmallow 可以很方便的对自定义对象进行序列化和反序列化 对object进行在序列化之前，需要为object创建一个schema,schema中的字段名必须与自定义的object中的成员一致 dumps method：obj -&gt; str, dump method：obj -&gt; dict 反序列化的 dict -&gt; obj 需要使用decorator：post_load自己实现 12345678910111213141516171819202122232425from marshmallow import Schema, fields, post_loadclass User: def __init__(self, name, email): self.name = name self.email = email def __repr__(self): return \"&lt;User(name=&#123;self.name!r&#125;)&gt;\".format(self=self)class UserSchema(Schema): name = fields.Str() email = fields.Email() @post_load def make_user(self, data, **kwargs): return User(**data)user_data = &#123; \"email\": \"ken@yahoo.com\", \"name\": \"Ken\",&#125;schema = UserSchema()result = schema.load(user_data)print(result) # 输出结果：&lt;User(name='Ken')&gt; References 序列化与反序列化 pickle module json module bytes RESTful API编写指南 Flask RESTful API开发之序列化与反序列化 marshmallow","categories":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/tags/Python/"},{"name":"Json","slug":"Json","permalink":"https://dreamer1103.github.io/tags/Json/"}]},{"title":"git clone后如何checkout到remote branch","slug":"clone后如何checkout到remote-branch","date":"2019-10-26T16:36:10.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/10/27/clone后如何checkout到remote-branch/","link":"","permalink":"https://dreamer1103.github.io/2019/10/27/clone%E5%90%8E%E5%A6%82%E4%BD%95checkout%E5%88%B0remote-branch/","excerpt":"","text":"what/why通常情况使用git clone github_repository_address下载下来的仓库使用git branch查看当前所有分支时只能看到master分支，但是想要切换到其他分支进行工作怎么办❓ 其实使用git clone下载的repository没那么简单😥，clone得到的是仓库所有的数据，不仅仅是复制在Github repository所能看到的master分支下的所有文件，clone下来的是仓库下的每一个文件和每一个文件的版本（也就是说所有的分支都被搞下来了咯），那为啥看不到，其实remote branch被隐藏了，需要使用git branch -a才能看到。 howemmm…，现在看到了，那么怎么切换到remote branch呢？（我太难了🙃），又到了查文档的时候了，一波操作过后了解到git checkout是有restore working tree files的功能的，可以用来restore remote branch，比如使用以下命令在本地创建个新分支track远程分支： 1$ git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt; 12# 例子，本地为远程分支CkaiGrac-PYMO创建的新分支名为yeshan，push时需要注意git checkout -b yeshan --track origin/CkaiGrac-PYMO tips：使用git checkout -t &lt;remote/branch&gt;默认会在本地建立一个和远程分支名字一样的分支 reference git-branch: https://git-scm.com/docs/git-branch git-checkout: https://git-scm.com/docs/git-checkout","categories":[{"name":"Git","slug":"Git","permalink":"https://dreamer1103.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dreamer1103.github.io/tags/Git/"}]},{"title":"使用Microsoft Edge Beta将网页变成应用","slug":"使用Microsoft-Edge-Beta将网页变成应用","date":"2019-10-11T15:50:56.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/10/11/使用Microsoft-Edge-Beta将网页变成应用/","link":"","permalink":"https://dreamer1103.github.io/2019/10/11/%E4%BD%BF%E7%94%A8Microsoft-Edge-Beta%E5%B0%86%E7%BD%91%E9%A1%B5%E5%8F%98%E6%88%90%E5%BA%94%E7%94%A8/","excerpt":"","text":"今天无聊的我打开了装了很久都没用的Microsoft Edge Beta，一波乱戳，惊讶的发现Microsoft Edge Beta居然有将网页打包为应用的功能😂 B站也有PC”客户端”了，真香😂","categories":[{"name":"随笔","slug":"随笔","permalink":"https://dreamer1103.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://dreamer1103.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"简单感受下Python内置数据类型常用操作的性能","slug":"简单了解下Python内置数据类型常用操作的性能","date":"2019-10-02T11:01:46.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/10/02/简单了解下Python内置数据类型常用操作的性能/","link":"","permalink":"https://dreamer1103.github.io/2019/10/02/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E4%B8%8BPython%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%A7%E8%83%BD/","excerpt":"生成一个列表的几种方式的性能对比12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-from timeit import Timerimport matplotlib.pyplot as plt# 列表常用操作性能测试# 迭代 + '+'def test1(): l = [] for i in range(1000): l = l + [i] # 迭代 + appenddef test2(): l = [] for i in range(1000): l.append(i)# 列表生成式def test3(): l = [i for i in range(1000)]# list构造函数 + rangedef test4(): l = list(range(1000))t1 = Timer(\"test1()\", \"from __main__ import test1\")# print(\"concat %f seconds\" % t1.timeit(number=1000))t2 = Timer(\"test2()\", \"from __main__ import test2\")# print(\"concat %f seconds\" % t2.timeit(number=1000))t3 = Timer(\"test3()\", \"from __main__ import test3\")# print(\"concat %f seconds\" % t3.timeit(number=1000))t4 = Timer(\"test4()\", \"from __main__ import test4\")# print(\"concat %f seconds\" % t4.timeit(number=1000))result = [t1.timeit(1000), t2.timeit(1000), t3.timeit(1000), t4.timeit(1000)]method = [\"for+ '+'\", \"for + append\", \"list comprehension\", \"list + range\"]plt.bar(method, result, color='rgby')# plt.legend('concat time')# print(zip(method, result))for x,y in zip(method, result): plt.text(x, y, \"%fs\" % y)plt.show()","text":"生成一个列表的几种方式的性能对比12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-from timeit import Timerimport matplotlib.pyplot as plt# 列表常用操作性能测试# 迭代 + '+'def test1(): l = [] for i in range(1000): l = l + [i] # 迭代 + appenddef test2(): l = [] for i in range(1000): l.append(i)# 列表生成式def test3(): l = [i for i in range(1000)]# list构造函数 + rangedef test4(): l = list(range(1000))t1 = Timer(\"test1()\", \"from __main__ import test1\")# print(\"concat %f seconds\" % t1.timeit(number=1000))t2 = Timer(\"test2()\", \"from __main__ import test2\")# print(\"concat %f seconds\" % t2.timeit(number=1000))t3 = Timer(\"test3()\", \"from __main__ import test3\")# print(\"concat %f seconds\" % t3.timeit(number=1000))t4 = Timer(\"test4()\", \"from __main__ import test4\")# print(\"concat %f seconds\" % t4.timeit(number=1000))result = [t1.timeit(1000), t2.timeit(1000), t3.timeit(1000), t4.timeit(1000)]method = [\"for+ '+'\", \"for + append\", \"list comprehension\", \"list + range\"]plt.bar(method, result, color='rgby')# plt.legend('concat time')# print(zip(method, result))for x,y in zip(method, result): plt.text(x, y, \"%fs\" % y)plt.show() list和dict的检索效率对比123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-import randomfrom timeit import Timerimport matplotlib.pyplot as pltlst_result = []d_result = []for i in range(10000,1000001,20000): t = Timer(\"random.randrange(%d) in x\" % i, \"from __main__ import random,x\") x = list(range(i)) lst_time = t.timeit(number=1000) x = &#123;j:None for j in range(i)&#125; d_time = t.timeit(number=1000) lst_result.append(lst_time) d_result.append(d_time) print(\"%d,%10.3f,%10.3f\" % (i, lst_time, d_time))test = [i for i in range(10000,1000001,20000)]plt.plot(test, lst_result, 'ro')plt.plot(test, d_result, 'bo')plt.legend(['List','Dictionary'])plt.show() del list[index]与del dict[key] 性能对比 average time complexity：$ O(n)\\ \\ vs\\ \\ O(1) $ 1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-import randomfrom timeit import Timerimport matplotlib.pyplot as pltsize = 20000l_result = []d_result = []for i in range(size): test_list = [i for i in range(size)] list_t = Timer(\"del test_list[%d]\" % i,\"from __main__ import test_list\") list_result = list_t.timeit(number=1) l_result.append(list_result) test_dict = &#123;j:None for j in range(size)&#125; dict_t = Timer(\"del test_dict[%d]\" % i,\"from __main__ import test_dict\") dict_result = dict_t.timeit(number=1) d_result.append(dict_result) # print(\"%d,%f,%f\" % (i, list_result, dict_result))plt.plot(range(size), l_result)plt.plot(range(size), d_result)plt.legend(['del list[index]', 'del dict[key]'])plt.show() 参考 matplotlib中文文档 TimeComplexity 北大数据结构与算法公开课 Python timeit","categories":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/tags/Python/"}]},{"title":"docker学习笔记","slug":"docker学习笔记","date":"2019-08-08T09:29:19.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/08/08/docker学习笔记/","link":"","permalink":"https://dreamer1103.github.io/2019/08/08/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Play With Docker一个免费使用的基于web界面的Docker环境 常用docker命令可使用docker COMMAND --help查看命令的用法 Docker镜像相关 1、docker image pull：用于下载镜像，镜像从远程镜像仓库服务的仓库中下载，默认从Docker Hub的仓库中拉取 1234# 格式：docker pull [OPTIONS] NAME[:TAG|@DIGEST]# 说明：如果给出tag，一般拉取latest，name一般为username/repository,digest为镜像摘要可不给出docker image pull ubuntu:latest# 这个拉取标签为latest的ubuntu官方镜像，latest: Pulling from library/ubuntu，latest不一定是最新镜像","text":"Play With Docker一个免费使用的基于web界面的Docker环境 常用docker命令可使用docker COMMAND --help查看命令的用法 Docker镜像相关 1、docker image pull：用于下载镜像，镜像从远程镜像仓库服务的仓库中下载，默认从Docker Hub的仓库中拉取 1234# 格式：docker pull [OPTIONS] NAME[:TAG|@DIGEST]# 说明：如果给出tag，一般拉取latest，name一般为username/repository,digest为镜像摘要可不给出docker image pull ubuntu:latest# 这个拉取标签为latest的ubuntu官方镜像，latest: Pulling from library/ubuntu，latest不一定是最新镜像 2、docker image ls：列出本地Docker主机上存储的镜像 3、docker image inspect：查看镜像的细节，包括镜像层数据和元数据 12# docker image inspect [OPTIONS] IMAGE [IMAGE...]# inspect后一般跟repository name或image id 4、docker image rm：用于删除镜像。如果镜像存在关联的容器，并且容器处于运行(Up)或停止(Exit)状态时，不允许删除该镜像。rm后可跟repository或image id 5、dicker image search：从Docker Hub查找镜像 6、docker image build：根据Dockerfile构建镜像 12# 例如：使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。docker build -t yeshan333/ubuntu:latest . 7、docker image history：用于查看镜像构建的相关信息 Docker容器相关 1、docker container run：用于启动新容器 123456789101112# 格式：docker run [OPTIONS] IMAGE [COMMAND] [ARG...]# 常用options：# -d: 后台运行容器，并返回容器ID；# -i: 以交互模式运行容器，通常与 -t 同时使用；# -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；# -P: 随机端口映射，容器内部端口随机映射到主机的高端口# -p: 指定端口映射，格式为：主机(宿主)端口:容器端口# --name=\"container-name\": 为容器指定一个名称；# 示例docker container run -it ubuntu:latest /bin/bash# 说明：-it使容器具备交互性并与终端连接，命令最后表明运行容器中的Bash Shell程序 2、docker container ls：列出所有运行状态的容器可用docker ps代替，如果加个*-a附加参数，会列出所有容器（包括处于停止状态的容器） 3、docker container stop：停止运行中的容器，并将其状态设置为Exited(0)，stop后跟container name或container id 4、docker container rm：用于删除停止运行的容器，rm后跟container name或container id，使用-f参数可强制删除运行中的容器 5、docker container exec：用于连接一个处于运行状态的容器 123# 例如：docker container exec -t &lt;container-name or container-id&gt; bash# 该命令会将docker主机中的shell连接到一个运行中的容器，在容器内部启动一个新的bash shell进程 6、docker container start：用于重启处于停止(Exited)状态的容器，start后跟container name或container id 7、docker container inspect：查看容器的配置信息和运行时信息，inspect后跟container name或container id 8、快捷键Ctrl+PQ用于断开docker主机的shell终端与容器终端的连接，并在退出后保证容器在后台运行 应用容器化 (Containerizing|Dockerizing)即将应用整合到容器中并且运行的过程 应用容器化的一般步骤 1、编写应用代码 2、创建Dockerfile，其中包括当前应用的描述、依赖以及如何运行这个应用 3、对Dockerfile执行docker image build命令 4、等待Docker将应用程序构建到Docker镜像中 Once your app is containerized (made into a Docker image), you’re ready to ship it and run it as a container.《Docker Deep Dive》 使用Dockerfile定制镜像 Dockerfile最佳实践 使用Dockerfile定制镜像 Dockerfile中以#开头的都是注释行，除注释之外，每一行都是一条指令指令的的一般格式：INSTRUCTION argument，INSTRUCTION一般都为大写 示例Dockerfile：https://github.com/yeshan333/psweb 123456789101112131415161718FROM alpineLABEL maintainer&#x3D;&quot;nigelpoulton@hotmail.com&quot;# Install Node and NPMRUN apk add --update nodejs nodejs-npm# Copy app to &#x2F;srcCOPY . &#x2F;srcWORKDIR &#x2F;src# Install dependenciesRUN npm installEXPOSE 8080ENTRYPOINT [&quot;node&quot;, &quot;.&#x2F;app.js&quot;] 说明： 每个Dockerfile文件文件的第一行一般都是FROM指令。FROM指定的镜像会作为当前镜像的一个基础镜像层，当前应用的剩余内容会作为新的镜像层添加到基础镜像层之上。，FROM建议引用官方镜像 LABEL指定当前镜像维护者，给镜像使用者一个沟通渠道 RUN apk add --update nodejs nodejs-npm将当前应用的依赖安装到镜像中，RUN指令会新建一个镜像层存储这些内容 COPY . /src会将应用相关文件从构建上下文复制到当前镜像中，这会新建一个镜像层 WORKDIR /src会为Dockerfile中未执行的指令设置工作目录 RUN npm install在当前工作目录中为应用安装依赖，这会新建一个镜像层 EXPOSE 8080对外提供一个web服务端口 ENTRYPOINT [&quot;node&quot;, &quot;./app.js&quot;]指定了当前镜像的入口程序，container运行时就会运行 构建镜像使用docker image build根据Dockerfile制作镜像，示例： 123# -t用于指定制作好的镜像的名字及标签，通常 name:tag 或者 name# 最后的 . 表示使用当前目录作为构建上下文docker image build -t web:latest . 使用docker image history web:latest可以查看构建镜像过程中执行了哪些指令 推送镜像到Docker Hub 推送镜像前建议使用以下命令给镜像打新标签12# new-tag建议以自己的 DockerHub ID&#x2F;new-tag 的格式命名，方便推送到自己的repodocker image tag &lt;current-tag&gt; &lt;new-tag&gt; 使用docker image push &lt;tag-name&gt;推送镜像，推送前需要docker login,记得测试打包好的应用再推送！！！ Dockerfile常用指令 指令 说明 FROM 指定要构建的镜像的基础镜像，一般为Dockerfile文件第一行 RUN 用于在镜像中执行命令，会新建一个镜像层 COPY 一般用于将应用代码copy到镜像中，这会新建一个镜像层 WORKDIR 用于设置Dockerfile中未执行的指令的工作目录 ENTRYPOINT 指定镜像以容器方式启动后默认运行的程序， ENTRYPOINT 的命令不会被docker run指定要执行的命令覆盖 CMD 指定容器启动时执行的命令，一个 Dockerfile 中只能有一个 CMD 指令，如果写了多个，那么只有最后一个会执行。CMD 和 ENTRYPOINT 同时存在时，CMD 中的内容会变成 ENTRYPOINT 中指令命令的默认参数，该参数可以被 docker run 时设置的命令覆盖 ENV 设置镜像中的环境变量 EXPOSE 记录应用所使用的网络端口 更多： Dockerfile指令详解 Dockerfile reference","categories":[{"name":"docker","slug":"docker","permalink":"https://dreamer1103.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://dreamer1103.github.io/tags/docker/"}]},{"title":"几个不错的Jupyter Notebook云端展示平台","slug":"几个不错的Jupyter Notebook云端展示平台","date":"2019-08-07T01:27:50.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/08/07/几个不错的Jupyter Notebook云端展示平台/","link":"","permalink":"https://dreamer1103.github.io/2019/08/07/%E5%87%A0%E4%B8%AA%E4%B8%8D%E9%94%99%E7%9A%84Jupyter%20Notebook%E4%BA%91%E7%AB%AF%E5%B1%95%E7%A4%BA%E5%B9%B3%E5%8F%B0/","excerpt":"jupyter nbviewerURL:https://nbviewer.jupyter.org/ 结合Github的示例用法：https://nbviewer.jupyter.org/github/ + &lt;用户名或者用户名/存放ipynb文件的仓库或者Gist ID&gt; 例如：https://nbviewer.jupyter.org/github/yeshan333/JupyterNotebook-Show-sample","text":"jupyter nbviewerURL:https://nbviewer.jupyter.org/ 结合Github的示例用法：https://nbviewer.jupyter.org/github/ + &lt;用户名或者用户名/存放ipynb文件的仓库或者Gist ID&gt; 例如：https://nbviewer.jupyter.org/github/yeshan333/JupyterNotebook-Show-sample 还行~ binderURL:https://mybinder.org 使用文档：https://mybinder.readthedocs.io/en/latest/index.html# 结合Github的示例用法：https://mybinder.org/v2/gh/ + &lt;用户名/仓库名&gt; + /分支名 + ?filepath= + ipynb文件名 例如：https://mybinder.org/v2/gh/yeshan333/JupyterNotebook-Show-sample/master?filepath=demo.ipynb 很nice啊，在线交互式环境，在线跑代码，就是渲染有点小慢 google colab官方介绍:https://colab.research.google.com/notebooks/welcome.ipynb，需要科学上网 结合Github的示例用法：https://colab.research.google.com/github/ + 用户名/ + 存放ipynb文件的仓库名/ + blob/ + 分支名 + 要展示的ipynb文件路径 示例：https://colab.research.google.com/github/yeshan333/JupyterNotebook-Show-sample/blob/master/demo.ipynb 也是个在线的交互式环境，很nice了","categories":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/tags/Python/"},{"name":"Jupyter","slug":"Jupyter","permalink":"https://dreamer1103.github.io/tags/Jupyter/"}]},{"title":"Latex基本语法简记","slug":"latex基本语法简记","date":"2019-06-18T07:05:57.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/06/18/latex基本语法简记/","link":"","permalink":"https://dreamer1103.github.io/2019/06/18/latex%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%AE%80%E8%AE%B0/","excerpt":"公式插入方式 行内公式可用\\(...\\)或$...$ 例如$ f(x)=x^2 $,显示为$ f(x)=x^2 $ 独立公式（单独另起一行,公式会居中），使用$$...$$或\\[...\\] 例如：$$ \\limit{f(x)dx} $$或$$ \\int_a^b{f(x)dx} $$ 1234561. 行内公式可用`\\(...\\)`或`$...$`- 例如`$ f(x)=x^2 $`,显示为$ f(x)=x^2 $2. 独立公式（单独另起一行,公式会居中），使用`$$...$$`或`\\[...\\]`- 例如：`$$ \\limit&#123;f(x)dx&#125; $$`或$$ \\int_a^b&#123;f(x)dx&#125; $$","text":"公式插入方式 行内公式可用\\(...\\)或$...$ 例如$ f(x)=x^2 $,显示为$ f(x)=x^2 $ 独立公式（单独另起一行,公式会居中），使用$$...$$或\\[...\\] 例如：$$ \\limit{f(x)dx} $$或$$ \\int_a^b{f(x)dx} $$ 1234561. 行内公式可用`\\(...\\)`或`$...$`- 例如`$ f(x)=x^2 $`,显示为$ f(x)=x^2 $2. 独立公式（单独另起一行,公式会居中），使用`$$...$$`或`\\[...\\]`- 例如：`$$ \\limit&#123;f(x)dx&#125; $$`或$$ \\int_a^b&#123;f(x)dx&#125; $$ 大括号的使用1234567891011121314151617181920212223方法一：$$ f(x)&#x3D;\\left\\&#123;\\begin&#123;aligned&#125;x &amp; &#x3D; &amp; \\cos(t) \\\\y &amp; &#x3D; &amp; \\sin(t) \\\\z &amp; &#x3D; &amp; \\frac xy\\end&#123;aligned&#125;\\right.$$方法二：$$ F^&#123;HLLC&#125;&#x3D;\\left\\&#123;\\begin&#123;array&#125;&#123;rcl&#125;F_L &amp; &amp; &#123;0 &lt; S_L&#125;\\\\F^*_L &amp; &amp; &#123;S_L \\leq 0 &lt; S_M&#125;\\\\F^*_R &amp; &amp; &#123;S_M \\leq 0 &lt; S_R&#125;\\\\F_R &amp; &amp; &#123;S_R \\leq 0&#125;\\end&#123;array&#125; \\right. $$方法三:$$f(x)&#x3D;\\begin&#123;cases&#125;0&amp; \\text&#123;x&#x3D;0&#125;\\\\1&amp; \\text&#123;x!&#x3D;0&#125;\\end&#123;cases&#125;$$ 方法一：$$ f(x)=\\left{\\begin{aligned}x &amp; = &amp; \\cos(t) \\y &amp; = &amp; \\sin(t) \\z &amp; = &amp; \\frac xy\\end{aligned}\\right.$$方法二：$$ F^{HLLC}=\\left{\\begin{array}{rcl}F_L &amp; &amp; {0 &lt; S_L}\\F^_L &amp; &amp; {S_L \\leq 0 &lt; S_M}\\F^_R &amp; &amp; {S_M \\leq 0 &lt; S_R}\\F_R &amp; &amp; {S_R \\leq 0}\\end{array} \\right. $$方法三:$$f(x)=\\begin{cases}0&amp; \\text{x=0}\\1&amp; \\text{x!=0}\\end{cases}$$ 符号表要输出字符 空格 # $ % &amp; _ { } ，用命令：\\空格 # \\$ \\% \\&amp; _ { } 运算符表关系运算符 命令 显示 命令 显示 \\pm $\\pm$ \\times $\\times$ \\div $\\div$ \\mid $\\mid$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\circ $\\circ$ \\ast $\\ast$ \\bigodot $\\bigodot$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\leq $\\leq$ \\geq $\\geq$ \\neq $\\neq$ \\approx $\\approx$ \\equiv $\\equiv$ \\sum $\\sum$ \\prod $\\prod$ 集合运算符 命令 显示 命令 显示 \\emptyset $\\emptyset$ \\in $\\in$ \\notin $\\notin$ \\subset $\\subset$ \\supset $\\supset$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\bigcap $\\bigcap$ \\bigcup $\\bigcup$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\biguplus $\\biguplus$ \\bigsqcup $\\bigsqcup$ &ensp; &ensp; 对数运算符 命令 显示 命令 显示 命令 显示 \\log $\\log$ \\lg $\\lg$ \\ln $\\ln$ 三角运算符 命令 显示 命令 显示 命令 显示 \\bot $\\bot$ \\angle $\\angle$ 30^\\circ $30^\\circ$ \\sin $\\sin$ \\cos $\\cos$ \\tan $\\tan$ \\cot $\\cot$ \\sec $\\sec$ \\csc $\\csc$ 微积分运算符 命令 显示 命令 显示 命令 显示 \\prime $\\prime$ \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\oint $\\oint$ \\lim $\\lim$ \\infty $\\infty$ \\nabla $\\nabla$ &ensp; &ensp; 逻辑运算符 命令 显示 命令 显示 命令 显示 \\because $\\because$ \\therefore $\\therefore$ \\forall $\\forall$ \\exists $\\exists$ \\not= $\\not=$ \\not&gt; $\\not&gt;$ \\not&lt; $\\not&lt;$ \\not\\subset $\\not\\subset$ &ensp; &ensp; 其它符号戴帽和连线符号 命令 显示 命令 显示 命令 显示 \\hat{y} $\\hat{y}$ \\check{y} $\\check{y}$ \\breve $\\breve{y}$ \\overline{a+b+c+d} $\\overline{a+b+c+d}$ \\underline{a+b+c+d} $\\underline{a+b+c+d}$ \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} $\\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0}$ 箭头符号 命令 显示 命令 显示 命令 显示 \\uparrow $\\uparrow$ \\downarrow $\\downarrow$ \\Uparrow $\\Uparrow$ \\Downarrow $\\Downarrow$ \\rightarrow $\\rightarrow$ \\leftarrow $\\leftarrow$ \\Rightarrow $\\Rightarrow$ \\Leftarrow $\\Leftarrow$ \\longrightarrow $\\longrightarrow$ \\Longrightarrow $\\Longrightarrow$ \\longleftarrow $\\longleftarrow$ \\Longleftarrow $\\Longleftarrow$ 矩阵基本语法 起始标记\\begin{matrix},结束标记\\end{matrix} 每一行末标记\\\\进行换行，行间元素以&amp;分隔用于对齐。 12345$$\\begin&#123;matrix&#125;1&amp;0&amp;0\\\\0&amp;1&amp;0\\\\0&amp;0&amp;1\\\\\\end&#123;matrix&#125;$$ $$\\begin{matrix}1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\\\\end{matrix}$$ 进阶 可用下列词替换matrix设置矩阵边框 pmatrix、bmatrix、Bmatrix：小括号、中括号、大括号边框 vmatrix、Vmatrix：单竖线、双竖线边框 省略元素 横省略号：\\cdots 竖省略号：\\vdots 斜省略号：\\ddots 123456$$\\begin&#123;Bmatrix&#125;&#123;a_&#123;11&#125;&#125;&amp;&#123;a_&#123;12&#125;&#125;&amp;&#123;\\cdots&#125;&amp;&#123;a_&#123;1n&#125;&#125;\\\\&#123;a_&#123;21&#125;&#125;&amp;&#123;a_&#123;22&#125;&#125;&amp;&#123;\\cdots&#125;&amp;&#123;a_&#123;2n&#125;&#125;\\\\&#123;\\vdots&#125;&amp;&#123;\\vdots&#125;&amp;&#123;\\ddots&#125;&amp;&#123;\\vdots&#125;\\\\&#123;a_&#123;m1&#125;&#125;&amp;&#123;a_&#123;m2&#125;&#125;&amp;&#123;\\cdots&#125;&amp;&#123;a_&#123;mn&#125;&#125;\\\\\\end&#123;Bmatrix&#125;$$ $$\\begin{Bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\\cdots}&amp;{a_{1n}}\\{a_{21}}&amp;{a_{22}}&amp;{\\cdots}&amp;{a_{2n}}\\{\\vdots}&amp;{\\vdots}&amp;{\\ddots}&amp;{\\vdots}\\{a_{m1}}&amp;{a_{m2}}&amp;{\\cdots}&amp;{a_{mn}}\\\\end{Bmatrix}$$ 希腊字母表 命令 显示 命令 显示 \\alpha $\\alpha$ \\beta $\\beta$ \\gamma $\\gamma$ \\delta $\\delta$ \\epsilon $\\epsilon$ \\zeta $\\zeta$ \\eta $\\eta$ \\theta $\\theta$ \\iota $\\iota$ \\kappa $\\kappa$ \\lambda $\\lambda$ \\mu $\\mu$ \\nu $\\nu$ \\xi $\\xi$ \\pi $\\pi$ \\rho $\\rho$ \\sigma $\\sigma$ \\tau $\\tau$ \\upsilon $\\upsilon$ \\phi $\\phi$ \\chi $\\chi$ \\psi $\\psi$ \\omega $\\omega$ &ensp; &ensp; 如果需要大写的希腊字母，将命令首字母大写即可 例如：\\Gamma,显示$ \\Gamma $ 如果要将字母斜体显示，使用\\var前缀即可 例如：\\varGamma，显示$ \\varGamma $ 杂项 分组： 使用{}将具有相同等级的内容扩入其中，成组处理。 比如：\\10^10呈现为$10^10$，10^{10}呈现为$10^{10}$。 空格： 单个空格：a\\ b，$a\\ b$ 四个空格：a\\quad b,$a\\quad b$ 上标^，下标_ 尖括号\\langle\\rangle：$\\langle\\rangle$ 使用\\left或\\right使符号大小与临近的公式符号相适应，对比如下： (\\frac{x}{y})：$(\\frac{x}{y})$ \\left(\\frac{x}{y}\\right)：$\\left(\\frac{x}{y}\\right)$ 分式： \\frac{1}{3}：$\\frac{1}{3}$ 1 \\over 3：$1 \\over 3$ 开根\\sqrt[n]{3}：$\\sqrt[n]{3}$ 省略号： \\ldots：与文本底线对齐的省略号 \\cdots：与文本中线对齐的省略号 $f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2$：$f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2$ 综合运用示范123% 极限运算$$\\lim\\limits_&#123;n \\rightarrow +\\infty&#125; \\frac&#123;1&#125;&#123;n(n+1)&#125;$$$$\\lim_&#123;n \\rightarrow +\\infty&#125; \\frac&#123;1&#125;&#123;n(n+1)&#125;$$ $$\\lim\\limits_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)}$$ $$\\lim_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)}$$ 1$$ \\left[J_\\alpha(x) &#x3D; \\sum_&#123;m&#x3D;0&#125;^\\infty \\frac&#123;(-1)^m&#125;&#123;m! \\Gamma (m + \\alpha + 1)&#125; &#123;\\left(&#123; \\frac&#123;x&#125;&#123;2&#125; &#125;\\right)&#125;^&#123;2m + \\alpha&#125;\\right] $$ $$ \\left[J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha}\\right] $$ 参考 MathJax使用LaTeX语法编写数学公式教程 MathJax 语法参考 基本数学公式语法(of MathJax) MathJax basic tutorial and quick reference","categories":[{"name":"math","slug":"math","permalink":"https://dreamer1103.github.io/categories/math/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://dreamer1103.github.io/tags/Latex/"}]},{"title":"Jupyter Notebooks的简单了解","slug":"Jupyter-Notebooks的简单了解","date":"2019-05-22T14:00:25.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/05/22/Jupyter-Notebooks的简单了解/","link":"","permalink":"https://dreamer1103.github.io/2019/05/22/Jupyter-Notebooks%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/","excerpt":"撸一手Jupyter","text":"玩Python这么久了，连Jupyter都不会，有点捞，今天补一补这方面的操作。。。。 Jupyter Notebooks&ensp;&ensp;Jupyter Notebooks 是一款开源的网络应用，我们可以将其用于创建和共享代码与文档。其提供了一个环境，你无需离开这个环境，就可以在其中编写你的代码、运行代码、查看输出、可视化数据并查看结果。因此，这是一款可执行端到端的数据科学工作流程的便捷工具，其中包括数据清理、统计建模、构建和训练机器学习模型、可视化数据等等。 安装pip install ipython jupyter上手上手在终端输入jupyter notebook启动Jupyter notebooks,它会在默认浏览器中打开，地址是http://localhost:8888/tree。 新建个Python文件试试 Jupyter常用键盘快捷键esc和enter用于切换Jupyter的键盘输入模式，esc切换为命令模式（blue），enter切换为编辑模式（green） 命令模式(常用) 连续按两下D，删除当前活跃单元 按A在活跃单元上插入一个单元，按B在活跃单元下插入一个单元 按Z撤销被删除的单元 按Y将当前单元变为代码单元 按Shift+方向上下键选择多个单元，按Shift+M可以合并选择的单元 Ctrl+Shift+F用于打开命令面板 按H查看快捷键完整列表 编辑模式（常用） Ctrl+S保存（防死机(๑•̀ㅂ•́)و✧） Ctrl+Home回到单元起始位置 Ctrl+Enter运行整个单元块 Alt+Enter运行当前活跃单元块，并在当前活跃单元块下方创建新的单元块 emmm可以划水了。。。。 了解更多： 始于Jupyter Notebooks：一份全面的初学者实用指南 jupyter notebook使用技巧 Jupyter介绍和使用 中文版","categories":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/tags/Python/"}]},{"title":"HTTPie的使用","slug":"HTTPie的使用","date":"2019-04-23T15:47:48.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/04/23/HTTPie的使用/","link":"","permalink":"https://dreamer1103.github.io/2019/04/23/HTTPie%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"HTTPie","text":"HTTPie（发音为aitch-tee-tee-pie）是一个命令行HTTP客户端。其目标是使与Web服务的CLI交互尽可能人性化。它提供了一个简单的http命令，允许使用简单自然的语法发送任意HTTP请求，并显示彩色输出。HTTPie可用于测试，调试以及通常与HTTP服务器交互。 HTTPie官方文档 https://httpie.org/doc windows下安装 pip install --upgrade httpieHTTPie的简单使用一个完整的请求语句的大概样子http [选项(flags)] [方法] URL [查询字符串/数据字段/首部字段]HTTPie数据语法 类型 符号 示例 URL参数 == param==value 首部字段 : Name:value 数据字段 = field=value 原生JSON字段 := field:=json 表单上传字段 @ field@dir/file 示例1234567891011121314# 下载文件$ http --download www.jb51.net/my_file.zip# 提交表单$ http -f POST www.jb51.net name='Dan Nanni' comment='Hi there'# HTTPie的默认数据类型为JSON格式的$ http PUT example.org name=John email=john@example.org# 使用代理$ http --proxy=http:http://10.10.1.10:3128 --proxy=https:https://10.10.1.10:1080 example.org# 定制请求头$ http www.test.com User-Agent:Xmodulo/1.0 Referer:http://www.imike.me MyParam:Foo 放着先。。。。。。。。。占个位","categories":[],"tags":[]},{"title":"Git Branch Practice","slug":"Git-Branch-Practice","date":"2019-04-08T04:52:55.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/04/08/Git-Branch-Practice/","link":"","permalink":"https://dreamer1103.github.io/2019/04/08/Git-Branch-Practice/","excerpt":"Git Branch Practice","text":"最近在弄一个东西，基本的功能已经弄好了，现在想再扩展一起其他功能，但这样势必会改动原有代码，我又不想破坏原有的代码逻辑，方便以后查看。记得Git有个分支工作流可以很好的满足我的需求(๑•̀ㅂ•́)و✧。emmm，很久没发文了，record一下吧。(ノへ￣、) 使用到的命令12345678910111213$ git branch # 显示所有本地分支$ git branch &lt;new branch&gt; # 创建新分支$ git checkout &lt;branch&gt; # 切换到指定分支$ git branch -d &lt;branch&gt; # 删除本地分支$ git push --set-upstream origin &lt;branch&gt; # 将本地分支与远程分支关联$ git push origin --delete &lt;branch&gt; # 删除远程分支$ git tag -n # 列出所有本地标签以及相关信息$ git tag &lt;tagname&gt; # 基于最新提交创建标签&amp; git tag &lt;tagname&gt; -m \"备注信息\" # 基于最新提交创建含备注信息的标签$ git tag -d &lt;tagname&gt; # 删除标签$ git push orign &lt;tagname&gt; # 将指定信息推送到远程仓库$ git push --tags # 推送所有标签到远程仓库 操作~操作 emmm，顺便试试tag","categories":[{"name":"Git","slug":"Git","permalink":"https://dreamer1103.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dreamer1103.github.io/tags/Git/"}]},{"title":"我与vim的亲密接触(ˉ▽￣～)","slug":"我与vim的亲密接触","date":"2019-03-20T15:51:17.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/03/20/我与vim的亲密接触/","link":"","permalink":"https://dreamer1103.github.io/2019/03/20/%E6%88%91%E4%B8%8Evim%E7%9A%84%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6/","excerpt":"emmm，闲来无事，打算了解下神奇vim（用来zhuangbi）。在终端操作很帅(ˉ▽￣～)~~！什么是vim？？Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vi/vim的使用vi/vim有三种模式： 命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。刚启动时就是这个模式。 输入模式：正常的文本录入。 末行模式：保存或退出文档，以及设置编辑环境。又可成为底线命令模式。","text":"emmm，闲来无事，打算了解下神奇vim（用来zhuangbi）。在终端操作很帅(ˉ▽￣～)~~！什么是vim？？Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vi/vim的使用vi/vim有三种模式： 命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。刚启动时就是这个模式。 输入模式：正常的文本录入。 末行模式：保存或退出文档，以及设置编辑环境。又可成为底线命令模式。 常用命令命令模式常用命令： 命令 作用 dd 删除（剪切）光标所在整行 5dd 删除（剪切）从光标处开始的5行 yy 复制光标所在的整行 5yy 复制从光标处开始的5行 n 显示搜索命令定位到的下一个字符串 N 显示搜索命令定位到的上一个字符串 u 撤销上一步的操作 p 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 末行模式可用命令： 命令 作用 :w 保存 :q 退出 :q! 强制退出（放弃对文档内容的修改） :wq! 强制保存退出 :set nu 显示行号 :set nonu 不显示行号 :命令 执行该命令 :整数 跳转到该行 :s/one/two 将当前光标所在行的第一个one替换成two :s/one/two/p 将当前光标所在行的所有one替换成two :%s/one/two/g 将全文中的所有one替换成two ?字符串 在文本中从下到上搜索该字符串 /字符串 在文本中从上到下搜索该字符串 我与它的亲密接触。。。。。 相关 vim官网：https://www.vim.org/ vim快捷键键位图：https://www.jianshu.com/p/8b986f572a61","categories":[{"name":"Linux","slug":"Linux","permalink":"https://dreamer1103.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://dreamer1103.github.io/tags/Linux/"}]},{"title":"SQLAlchemy建立数据库模型之间的关系","slug":"SQLAlchemy建立数据库模型之间的关系","date":"2019-03-20T09:45:17.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/03/20/SQLAlchemy建立数据库模型之间的关系/","link":"","permalink":"https://dreamer1103.github.io/2019/03/20/SQLAlchemy%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","excerpt":"常见关系： 一对多关系 多对一关系 多对多关系 一对一关系 一对多关系（一个作者，多篇文章）123456789101112131415161718192021222324252627282930## 一对多关系，单作者-多文章，外键不可少## 外键(ForeignKey)总在多的那边定义,关系(relationship)总在单的那边定义class Author(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) phone = db.Column(db.String(20)) # articles为关系属性(一个集合，可以像列表一样操作，在关系的出发侧定义 ## relationship()函数的第一个参数为关系另一侧的模型名称(Article) articles = db.relationship('Article')class Article(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(15), index=True) body = db.Column(db.Text) # 传入ForeignKey的参数形式为：\"表名.字段名\" ## 模型类对应的表名由Flask-SQLAlchemy生成，默认为类名称的小写形式，多个单词通过下划线分隔 author_id = db.Column(db.Integer, db.ForeignKey('author.id')) ## 外键字段(author_id)和关系属性(articles)的命名没有限制## 建立关系可通过操作关系属性进行&gt;&gt;&gt;shansan = Author(name=\"shansan\")&gt;&gt;&gt;hello = Article(title=\"Hello world !\")&gt;&gt;&gt;boy = Article(title=\"Hello Boy !\")&gt;&gt;&gt;db.session.add(shansan) # 将创建的数据库记录添加到会话中&gt;&gt;&gt;db.session.add(hello)&gt;&gt;&gt;db.session.add(boy)&gt;&gt;&gt;shansan.articles.append(hello) # 操作关系属性&gt;&gt;&gt;shansan.articles.append(boy)&gt;&gt;&gt;db.session.commit()","text":"常见关系： 一对多关系 多对一关系 多对多关系 一对一关系 一对多关系（一个作者，多篇文章）123456789101112131415161718192021222324252627282930## 一对多关系，单作者-多文章，外键不可少## 外键(ForeignKey)总在多的那边定义,关系(relationship)总在单的那边定义class Author(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) phone = db.Column(db.String(20)) # articles为关系属性(一个集合，可以像列表一样操作，在关系的出发侧定义 ## relationship()函数的第一个参数为关系另一侧的模型名称(Article) articles = db.relationship('Article')class Article(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(15), index=True) body = db.Column(db.Text) # 传入ForeignKey的参数形式为：\"表名.字段名\" ## 模型类对应的表名由Flask-SQLAlchemy生成，默认为类名称的小写形式，多个单词通过下划线分隔 author_id = db.Column(db.Integer, db.ForeignKey('author.id')) ## 外键字段(author_id)和关系属性(articles)的命名没有限制## 建立关系可通过操作关系属性进行&gt;&gt;&gt;shansan = Author(name=\"shansan\")&gt;&gt;&gt;hello = Article(title=\"Hello world !\")&gt;&gt;&gt;boy = Article(title=\"Hello Boy !\")&gt;&gt;&gt;db.session.add(shansan) # 将创建的数据库记录添加到会话中&gt;&gt;&gt;db.session.add(hello)&gt;&gt;&gt;db.session.add(boy)&gt;&gt;&gt;shansan.articles.append(hello) # 操作关系属性&gt;&gt;&gt;shansan.articles.append(boy)&gt;&gt;&gt;db.session.commit() 基于一对多的双向关系（bidirectional relationship）在这里我们希望可以在Book类中存在这样一个属性：通过调用它可以获取对应的作者的记录，这类返回单个值的关系属性称为标量关系属性 1234567891011121314151617181920212223# 建立双向关系时，关系两边都有关系函数# 在关系函数中，我们使用back_populates参数连接对方，参数的值设置为关系另一侧的关系属性名class Writer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) # back_populates的参数值为关系另一侧的关系属性名 books = db.relationship('Book', back_populates='writer') def __repr__(self): return '&lt;Writer %r&gt;' % self.nameclass Book(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(50), index=True) writer_id = db.Column(db.Integer, db.ForeignKey('writer.id')) writer = db.relationship('Writer', back_populates='books') def __repr__(self): return '&lt;Book %r&gt;' % self.name# 设置双向属性后，我们既可以通过集合属性操作关系，也可通过标量关系属性操作关系 多对一关系（多个市民都在同一个城市）123456789101112# 外键总在多的一侧定义## 多对一关系中，外键和关系属性都在多的一侧定义## 这里的关系属性是标量关系属性（返回单一数据）class Citizen(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(20), unique=True) city_id = db.Column(db.Integer, db.ForeignKey('city.id')) city = db.relationship('City')class City(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(20), unique=True) 一对一关系（国家和首都）12345678910111213## 一对一关系，将关系函数的uselist参数设为False，使得集合关系属性无法使用列表语义操作## 这里使用的是一对一双向关系class Country(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(20), unique=True) capital = db.relationship('Capital', uselist=False)class Capital(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(20), unique=True) country_id= db.Column(db.Integer, db.ForeignKey('country.id')) country = db.relationship('Country') 多对多双向关系（老师和学生） 多对多关系的建立需要使用关联表（association table）。关联表不存储数据，只用来存储关系两侧模型的外键对应关系 定义关系两侧的关系函数时，需要添加一个secondary参数，值设为关联表的名称 关联表由使用db.Table类定义，传入的第一个参数为关联表的名称 我们在关联表中将多对多的关系分化成了两个一对多的关系 1234567891011121314151617181920## 多对多关系，使用关联表（association table），关联表由db.Table定义## 关系函数需要设置secondary参数，值为关系表名association_table = db.Table('association_table', db.Column('student_id', db.Integer, db.ForeignKey('teacher.id')), db.Column('teacher_id', db.Integer, db.ForeignKey('student.id')) )class Student(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) grade = db.Column(db.String(20)) teachers = db.relationship('Teacher', secondary=association_table,back_populates='students')class Teacher(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) office = db.Column(db.String(20)) students = db.relationship('Student', secondary=association_table, back_populates='teachers') 常用的SQLAlchemy关系函数参数和常用的SQLAlchemy关系记录加载方式（lazy参数可选值） 使用关系函数定义的属性不是数据库字段，而是类似于特定的查询函数 当关系属性被调用时，关系函数会加载相应的记录 相关http://www.sqlalchemy.org/ https://github.com/sqlalchemy/sqlalchemy https://github.com/mitsuhiko/flask-sqlalchemy","categories":[{"name":"Flask","slug":"Flask","permalink":"https://dreamer1103.github.io/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://dreamer1103.github.io/tags/Flask/"}]},{"title":"Flask的请求钩子与上下文简记","slug":"Flask的请求钩子与上下文简记","date":"2019-03-16T14:32:05.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/03/16/Flask的请求钩子与上下文简记/","link":"","permalink":"https://dreamer1103.github.io/2019/03/16/Flask%E7%9A%84%E8%AF%B7%E6%B1%82%E9%92%A9%E5%AD%90%E4%B8%8E%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%80%E8%AE%B0/","excerpt":"请求钩子(Hook) 在客户端和服务器交互的过程中，有些准备工作或扫尾工作需要处理，比如：在请求开始时，建立数据库连接；在请求结束时，指定数据的交互格式。为了让&gt;每个视图函数避免编写重复功能的代码，Flask提供了通用设施的功能，即请求钩子。通过请求钩子，我们可以对请求进行预处理(preprocessing)和后处理&gt;(postprocessing)。 Flask的请求钩子通过装饰器实现，每个钩子可以注册任意多个处理函数，默认的五种请求钩子如下: 钩子 说明 before_first_request 注册一个函数，在处理请求前运行 before_request 注册一个函数，在处理每个请求前运行 after_request 注册一个函数，如果有未处理的一场抛出。会在每个请求结束后运行 teardown_request 注册一个函数，即使有未处理的异常抛出，会在每个请求介绍后执行。如果发生异常，会传入异常对象作为参数注册到函数中 after_this_request 在视图函数内注册一个函数，在这个请求结束后运行","text":"请求钩子(Hook) 在客户端和服务器交互的过程中，有些准备工作或扫尾工作需要处理，比如：在请求开始时，建立数据库连接；在请求结束时，指定数据的交互格式。为了让&gt;每个视图函数避免编写重复功能的代码，Flask提供了通用设施的功能，即请求钩子。通过请求钩子，我们可以对请求进行预处理(preprocessing)和后处理&gt;(postprocessing)。 Flask的请求钩子通过装饰器实现，每个钩子可以注册任意多个处理函数，默认的五种请求钩子如下: 钩子 说明 before_first_request 注册一个函数，在处理请求前运行 before_request 注册一个函数，在处理每个请求前运行 after_request 注册一个函数，如果有未处理的一场抛出。会在每个请求结束后运行 teardown_request 注册一个函数，即使有未处理的异常抛出，会在每个请求介绍后执行。如果发生异常，会传入异常对象作为参数注册到函数中 after_this_request 在视图函数内注册一个函数，在这个请求结束后运行 假如我们创建了三个视图函数A、B、C，其中视图C使用了after_this_request钩子，那么当请求A进入后，整个请求处理周期的请求处理函数调用流程如图: 上下文 什么是上下文？上下文相当于一个容器，它保存了程序运行过程中的一些信息，它是当前环境的一个快照(snapshot)。Flask中有两种上下文，程序上下文(application context)和请求上下文(request context)。程序上下文中包含了程序运行所必须的信息；请求上下文里包含了请求的各种信息，比如请求的URL、HTTP方法等 上下文全局变量我们知道，Flask将请求报文封装在request对象中。按照一般的思路，如果我们要在视图函数中使用它，就得把它作为参数传入视图函数，就像我们接收URL变量一样。但这样就会导致大量的重复，而且增加了的程序的负担。不一般的是，我们可以从Flask导入一个全局的request变量，在视图函数中直接调用request的属性获取数据。这是为什么？因为Flask会在每个请求产生后后自动激活当前请求的上下文，激活请求上下文后，request被临时设置为全局可访问。在每个请求结束后，Flask就会销毁对应的请求上下文。 Flask提供的四个上下文全局变量如下： 变量名 上下文类别 说明 current_app 程序上下文 指向处理请求的当前程序实例 g 程序上下文 替代Python的全局变量用法，确保仅在当前请求可用，用于存储全局数据，每次请求都会重设 request 请求上下文 封装客户端发出的请求报文数据 session 请求上下文 用于记住请求之间的数据，通过签名的Cookie实现 不同的视图函数中，request对象都表示和视图函数对应的请求，也就是当前请求 程序存在多个程序实例的情况，使用current_app可获取对应的实例 上下文的激活请求进入时，Flask会自动激活请求上下文，此时程序上下文也被自动激活。请求处理完毕后，请求上下文和程序上下文也会自动销毁。两者具有相同的生命周期。 Flask自动激活上下文的情况： 使用flask run命令启动程序时 使用旧的app.run()方法启动程序时 执行使用@app.cli.command()装饰器注册的flask命令时 使用flask shell命令启动Python Shell时 手动激活的方法: 使用with语句，程序上下文对象可通过app.app_context()获取 使用push（）方法激活程序上下文 请求上下文可以通过test_request_context()方法临时创建 12345&gt;&gt;&gt; from app import app&gt;&gt;&gt; from flask import current_app&gt;&gt;&gt; with app.app_context(): ... current_app.name'app' 1234567&gt;&gt;&gt; from app import app&gt;&gt;&gt; from flask import current_app&gt;&gt;&gt; app_ctx = app.app_context()&gt;&gt;&gt; app_ctx.push()&gt;&gt;&gt; current_app.name'app'&gt;&gt;&gt; app_ctx.pop() 12345&gt;&gt;&gt; from app import app&gt;&gt;&gt; from flask import request&gt;&gt;&gt; with app.test_request_context('/hello'):... request.method'GET' 参考：https://book.douban.com/subject/30310340/","categories":[{"name":"Flask","slug":"Flask","permalink":"https://dreamer1103.github.io/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://dreamer1103.github.io/tags/Flask/"}]},{"title":"将本地项目推送到GitHub远程仓库","slug":"将本地项目推送到GitHub远程仓库","date":"2019-03-08T15:59:28.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/03/08/将本地项目推送到GitHub远程仓库/","link":"","permalink":"https://dreamer1103.github.io/2019/03/08/%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0GitHub%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"如何将本地项目推送到Github Tip：在本地要安装好Git，官网：https://git-scm.com/ 一个学习Git的好地方：https://try.github.io/ 在线闯关实战，边练边学的好地方：https://learngitbranching.js.org/ 方法一：使用https推送12345678910111213# 步骤# 1.创建一个目录mkdir Test# 2.将当前目录变为git管理仓库git init# 3.将文件添加到版本库，这里将目录下的所有文件都添加进去了git add .# 4.告诉git将文件提交到仓库git commit -m \"first-commit\"# 5.将当前仓库与远程仓库关联git remote add origin 远程仓库的https地址 # eg: git remote add https://github.com/ssmath/Test.git# 6.将仓库内master分支的所有内容推送到远程仓库,这里会使用到Github的账号密码git push -u origin master","text":"如何将本地项目推送到Github Tip：在本地要安装好Git，官网：https://git-scm.com/ 一个学习Git的好地方：https://try.github.io/ 在线闯关实战，边练边学的好地方：https://learngitbranching.js.org/ 方法一：使用https推送12345678910111213# 步骤# 1.创建一个目录mkdir Test# 2.将当前目录变为git管理仓库git init# 3.将文件添加到版本库，这里将目录下的所有文件都添加进去了git add .# 4.告诉git将文件提交到仓库git commit -m \"first-commit\"# 5.将当前仓库与远程仓库关联git remote add origin 远程仓库的https地址 # eg: git remote add https://github.com/ssmath/Test.git# 6.将仓库内master分支的所有内容推送到远程仓库,这里会使用到Github的账号密码git push -u origin master 方法二：使用ssh推送 生成ssh密钥 12ssh-keygen -t rsa -C \"your email address\"# eg: ssh-keygen -t rsa -C \"1329441308@qq.com\" 找到生成的文件，复制id_rsa.pub文件中的内容，文件一般在用户目录下的.ssh目录中 使用密钥与远程仓库配对，检验能否成功通讯 ssh -T git@github.com # 检验能否成功通讯 推送本地文件到github","categories":[{"name":"Git","slug":"Git","permalink":"https://dreamer1103.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://dreamer1103.github.io/tags/Git/"}]},{"title":"vscode配置Pipenv工作环境","slug":"vscode配置Pipenv工作环境","date":"2019-03-03T15:25:30.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/03/03/vscode配置Pipenv工作环境/","link":"","permalink":"https://dreamer1103.github.io/2019/03/03/vscode%E9%85%8D%E7%BD%AEPipenv%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/","excerpt":"让vscode使用Pipenv工作环境1、查看Pipenv的位置1234# 先激活Pipenv环境pipenv shell# 获取当前虚拟环境的位置pipenv --venv 2、打开setting.json配置文件 Ctrl+Shift+P，输入settings，选择Open Settings(JSon) 将之前得到的Pipenv环境路径添加进去 “python.venvPath”: “C:\\Users\\Algorithm\\.virtualenvs”","text":"让vscode使用Pipenv工作环境1、查看Pipenv的位置1234# 先激活Pipenv环境pipenv shell# 获取当前虚拟环境的位置pipenv --venv 2、打开setting.json配置文件 Ctrl+Shift+P，输入settings，选择Open Settings(JSon) 将之前得到的Pipenv环境路径添加进去 “python.venvPath”: “C:\\Users\\Algorithm\\.virtualenvs” 3、重启vscode 参考https://segmentfault.com/a/1190000017558652 https://blog.csdn.net/weixin_34294649/article/details/87518937","categories":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/tags/Python/"}]},{"title":"Happy New Year !","slug":"Happy-New-Year","date":"2019-02-04T16:00:00.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/02/05/Happy-New-Year/","link":"","permalink":"https://dreamer1103.github.io/2019/02/05/Happy-New-Year/","excerpt":"","text":"12345678910111213141516171819202122232425262728C：printf(&quot;Happy New Year&quot;);C++ : cout&lt;&lt;&quot;Happy New Year&quot;;Objectivec: NSLog(@&quot;Happy New Year!&quot;);QBasic : Print &quot;Happy New Year&quot;Asp : Response.Write &quot;Happy New Year&quot;PHP : echo &quot;Happy New Year&quot;;Ruby: puts &quot;Happy New Year!&quot;JavaScript: alert(&quot;Happy New Year&quot;)VBScript:MsgBox &quot;Happy New Year&quot;JavaScript: document.write(&quot;Happy New Year&quot;)JavaScript: console.log(&#39; Happy New Year&#39;);xml &lt;TextView android:text&#x3D;&quot;Happy New Year! &quot; &#x2F;&gt; Delphi: ShowMessage(&#39;Happy New Year！&#39;);VB: Msg(&quot;Happy New Year！&quot;)VC: MessageBox(&quot;Happy New Year！&quot;);shell: echo Happy New Yearperl: print &#39;Happy New Year&#39;java: System.out.println(&quot;Happy New Year&quot;);LISP:(format t &quot;Happy New Year!~%&quot;)powerBuilder:messagebox（&quot;Happy New Year&quot;)C#：System.Console.WriteLine(&quot;Happy New Year!&quot;)COBOL:DISPLAY &#39;Happy New Year!&#39;Python:print(&quot;Happy New Year！&quot;)aswing:JOptionPane.showMessageDialog(&quot;happy&quot;,&quot;Happy New Year！&quot;)flex:Alert.show(&quot;Happy New Year！&quot;);Clojure: (println &quot;Happy New Year&quot;) verilog&#x2F;systemverilog&#x2F;e $display(&quot;Happy New Year&quot;) as:trace(&quot;Happy New Year！&quot;);","categories":[{"name":"blog","slug":"blog","permalink":"https://dreamer1103.github.io/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://dreamer1103.github.io/tags/blog/"}]},{"title":"HTML&&CSS(划水~~~)","slug":"HTML-CSS-划水","date":"2019-01-22T09:09:40.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/01/22/HTML-CSS-划水/","link":"","permalink":"https://dreamer1103.github.io/2019/01/22/HTML-CSS-%E5%88%92%E6%B0%B4/","excerpt":"HTML(超文本标记语言)HTML标签不区分大小写。 HTML属性 ID属性指定一个标识符，用于唯一标识页面元素，这些标识符主要供Javascript和CSS使用 class属性是一个全局属性，可用于建立元素编组。可以给多个元素指定相同的class属性，以便在CSS或Javascript中将这些元素作为一个编组来引用它们 style属性用于定义标签的样式。任何标签中都可以指定属性style。使用style属性可以为标签指定一个或多个样式规则，** 在style定义多条规则的方法是用分号将他们分开 **","text":"HTML(超文本标记语言)HTML标签不区分大小写。 HTML属性 ID属性指定一个标识符，用于唯一标识页面元素，这些标识符主要供Javascript和CSS使用 class属性是一个全局属性，可用于建立元素编组。可以给多个元素指定相同的class属性，以便在CSS或Javascript中将这些元素作为一个编组来引用它们 style属性用于定义标签的样式。任何标签中都可以指定属性style。使用style属性可以为标签指定一个或多个样式规则，** 在style定义多条规则的方法是用分号将他们分开 ** HTML的列表列表标签的特征： 每个列表都有一个指定列表类型的外部元素。 每个列表项都有自己的标签。 12345无序列表：&lt;ul&gt;&lt;/ul&gt;有序列表：&lt;ol&gt;&lt;/ol&gt;定义列表：&lt;dl&gt;&lt;/dl&gt;词汇列表的列表项为&lt;dt&gt;&lt;dd&gt;其他列表的列表项为&lt;li&gt; 有序列表（ol）有序列表默认的编号为罗马数字，可以使用属性style指定列表的编号样式，使用CSS属性list-style-type进行修改 1234567eg：&lt;ol style=\"list-style-type: upper-roman\"&gt; &lt;li&gt;罗马假日&lt;/li&gt; &lt;li&gt;平凡的世界&lt;/li&gt; &lt;li&gt;封神榜&lt;/li&gt; &lt;li&gt;无间道&lt;/li&gt;&lt;/ol&gt; 罗马假日 平凡的世界 封神榜 无间道 有序列表的编号样式 CSS属性list-style-type 描述 decimal(默认) 标准阿拉伯数字 lower-alpha 小写字母 upper-alpha 大写字母 lower-roman 小写罗马数字 upper-roman 大写罗马数字 无序列表（ul）无序列表编号样式 CSS属性list-style-type 描述 disc 圆盘，默认样式 square 实心正方形 circle 空心圆 123456eg：&lt;ul style=\"list-style-type: square\"&gt; &lt;li&gt;正方体&lt;/li&gt; &lt;li&gt;长方体&lt;/li&gt; &lt;li&gt;圆柱体&lt;/li&gt;&lt;/ul&gt; 正方体 长方体 圆柱体 定义列表（dl）定义列表的每个列表项都包含两部分 术语，标签为&lt;dt&gt; 术语的定义，标签为&lt;dt&gt; 1234567eg:&lt;dl&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;超文本标记语言，标准通用标记语言下的一个应用。是 网页制作必备的编程语言。&lt;/dd&gt; &lt;dt&gt;CSS&lt;/dt&gt; &lt;dd&gt;层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。&lt;/dd&gt;&lt;/dl&gt; HTML 超文本标记语言，标准通用标记语言下的一个应用。是 网页制作必备的编程语言。 CSS 层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 链接和锚链接到另一个页面的特定位置** 方法： 使用锚，即在链接的URL中指定要链接到的元素的ID ** 123456789eg:另一个页面2.html：&lt;h2 id=\"part4\"&gt;Part four&lt;/h2&gt;当前页面1.html：&lt;a href=\"2.html#part4\"&gt;go to part four&lt;/a&gt; 链接到当前页面的其他元素** 方法: 省略页面名就行，使用#号和ID ** 12eg:go to&lt;a href=\"#section5\"&gt;the fifth setion&lt;/a&gt; span标签span标签和style属性结合使用时，可取代很多标签，效果很nice 1234&lt;p&gt;Here is some&lt;span style=\"text-decoration: underline\"&gt; underline text&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Here is some&lt;span style=\"font-style:oblique\"&gt; oblique text&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Here is some&lt;span style=\"text-decoration:line-through\"&gt;line-through text&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Here is some&lt;span style=\"font-weight:120\"&gt; bolder text&lt;/span&gt;&lt;/p&gt; Here is some underline text Here is some oblique text Here is someline-through text Here is some bolder text HTML表格 标签 用途 &lt;table&gt;&lt;/table&gt; 定义表格 &#60;caption&#62;&#60;/caption&#62; 创建表题(可选) &#60;tr&#62;&#60;/tr&#62; 定义一个表格行，其中可包含表头单元格或数据单元格 &#60;th&#62;&#60;/th&#62; 定义一个表头单元格。表头单元格得内容通常显示为粗体，且在水平和竖直方向上都居中 &#60;td&#62;&#60;/td&#62; 定义一个数据单元格。数据单元格得内容通常显示为常规字体，在水平方向上左对齐，而且在垂直方向上居中 &#60;colgroup&#62;&#60;/colgroup&#62; 将一列或多列编组 &#60;col&#62;&#60;/col&#62; 用于定义表格列属性 &#60;thead&#62;&#60;/thead&#62; 创建表示表头的行编组。一个表格只能有一个表头 &#60;tfoot&#62;&#60;/tfoot&#62; 创建表示表尾的行编组。一个表格只能有一个表尾，它必须在表体前定义 &#60;tbody&#62;&#60;/tbody&#62; 定义一个或多个表示表体的行编组。一个表格可包含多个表头部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Table&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" style=\"width: 100%;\"&gt; &lt;caption&gt;&lt;b&gt;Science and Mathematic Class Schedules&lt;/b&gt;&lt;/caption&gt; &lt;colgroup style=\"width: 20%; text-align: center; vertical-align: top; background-color: #fcf;\"&gt; &lt;colgroup span=\"2\" style=\"width: 40%; vertical-align: top; background-color: #ccf;\"&gt; &lt;!-- span属性指定了列编组包含的列数，默认为1 --&gt; &lt;thead style=\"background-color: red;\"&gt; &lt;tr&gt; &lt;th&gt;Class&lt;/th&gt; &lt;th&gt;Room&lt;/th&gt; &lt;th&gt;Time&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody style=\"background-color: yellow;\"&gt; &lt;tr&gt; &lt;td&gt;Biology&lt;/td&gt; &lt;td&gt;Science Wing, Room 102&lt;/td&gt; &lt;td&gt;8:00 AM to 9:45 AM&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Science&lt;/td&gt; &lt;td&gt;Science Wing, Room 110&lt;/td&gt; &lt;td&gt;9:50 AM to 11:30 AM&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Physics&lt;/td&gt; &lt;td&gt;Science Wing, Room 107&lt;/td&gt; &lt;td&gt;1:00 PM to 2:45 PM&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody style=\"background-color: gray;\"&gt; &lt;tr&gt; &lt;td&gt;Geometry&lt;/td&gt; &lt;td&gt;Mathematics Wing, Room 236&lt;/td&gt; &lt;td&gt;8:00 AM to 9:45 Am&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Algebra&lt;/td&gt; &lt;td&gt;Mathematics Wing, Room 239&lt;/td&gt; &lt;td&gt;9:50 AM to 11:30 AM&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Trigonometry&lt;/td&gt; &lt;td&gt;Mathematics Wing, Room 245&lt;/td&gt; &lt;td&gt;1:00 PM to 2:45 PM&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;!-- tfoot一般放在tbody之前 --&gt; &lt;tfoot style=\"background-color: blue;\"&gt; &lt;tr&gt; &lt;th&gt;Class&lt;/th&gt; &lt;th&gt;Room&lt;/th&gt; &lt;th&gt;Time&lt;/th&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; text-align：指定水平对齐方式，可能取值：left、center、right vertical-align：指定垂直对齐方式，可能取值：top、middle、bottom 表格属性 属性 适用元素 用途 border table 指定表格是否带边框，默认不带。这个属性指定了表格边框的宽度 span col和colgroup 指定列编组包含多少列，必须是大于0的整数 colspan th或td 指定单元格将向右延伸横跨多少列 rowspan th或td 指定单元格将向下延伸横跨多少行 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;colspan and rowspan&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"10\" style=\"width: 100%\"&gt; &lt;caption&gt;&lt;b&gt;跨行跨列表格&lt;/b&gt;&lt;/caption&gt; &lt;!-- 跨列 --&gt; &lt;tr&gt; &lt;th colspan=\"2\"&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;!-- 跨行 --&gt; &lt;tr&gt; &lt;th rowspan=\"2\"&gt;辣椒&lt;/th&gt; &lt;td&gt;牛角椒&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;灯笼椒&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; HTML表单 标签/属性 用途 &#60;form&#62; 创建HTML表单。一个文档可包含多个表单，但是不可嵌套 action 标签&#60;form&#62;的一个属性，使用URL路径指定负责处理表单数据的服务器脚本 enctype &#60;form&#62;的一个属性，指定将表单数据发送给服务器前如何对其进行编码 method &#60;form&#62;的一个属性，指定如何将表单数据发送给服务器 &#60;input&#62; 一个用于创建表单控件以收集用户输入的信息 &#60;button&#62; 创建一个可包含HTML内容的按钮 &#60;textarea&#62; 创建多行的文本输入字段 &#60;select&#62; 创建一个菜单或可滚动列表，列表项由&#60;option&#62;创建 &#60;progress&#62; 显示任务完成进度的进度条 &#60;label&#62; 创建与表单控件配套的标签 &#60;fieldset&#62; 将表单控件编组 type 标签&#60;input的一个属性&#62;，指定了表单控件的类型，可能取值：text：创建一个单行文本输入字段password：&ensp;创建一个可遮挡用户输入的单行文本输入字段hidden：&ensp;创建一个隐藏的表单控件checkbox：&ensp;创建一个复选框search：&ensp;创建一个搜索关键字输入字段file：&ensp;创建一个文件上传控件让用户能够选择要随表单数据一起上传到服务器的文件color、date、datetime、email、url、reset等等 其它 items 说明 HTML语义标签 http://www.w3school.com.cn/html/html5_semantic_elements.asp pre标签 http://www.w3school.com.cn/tags/tag_pre.asp HTML字符实体 http://www.w3school.com.cn/html/html_entities.asp CSS(层叠样式表)样式表由一系列规则组成，大致结构如下 selector { property1: value1; property } 每条规则都以选择器(selector)打头,后面是一系列有花括号括起来的属性(property)和值(value)。 每个选择器可以指定任意数量的属性,但属性之间必须用分号分隔。 在最后一个属性/值对后面,可以有分号,也可以没有。 选择器(selector) 任何标签都可以用作CSS选择器，与这种选择器相关联的规则将应用于页面中所有指定的元素 可使用单个选择器将样式应用于多种元素，元素间用逗号间隔，比如： 123p, ul &#123; color: blue&#125; 下面这个规则与上面那个等价 1234567p &#123; color: blue;&#125;ul &#123; color: blue;&#125; 上下文选择器&ensp;&ensp;使用上下文选择器可以将样式应用于嵌套在指定元素内的元素 123ol em &#123; color: red;&#125; 上面那条规则应用于嵌套在有序列表中的em元素 123cite &#123; font-style: inherit; font-weight: 200;&#125;p cite &#123; font-style: italic; font-weight: 500;&#125;li cite&#123; font-style: normal; font-weight: bolder;&#125; 第一条为应用于所有cite标签的规则对于嵌套的cite标签，后两条规则说明了他们应该应用的样式 类 &amp;&amp; ID 选择器 将选择器应用于类，使用.+类名 将选择器应用于ID，使用#+ID，ID是独一无二的 给多个元素指定相同的样式可以使用类名，给单个元素指定样式可以使用ID 12345678910111213141516171819&lt;!-- 使用类型名 --&gt;&lt;div class=\"shan\"&gt;test&lt;/div&gt;&lt;!-- CSS --&gt;.shan &#123; color: red;&#125;&lt;!-- ------------------------------------ --&gt;&lt;!-- 使用ID --&gt;&lt;div id=\"footer\"&gt;Copyright 2019&lt;/div&gt;&lt;!-- CSS --&gt;#footer &#123; font-size: small;&#125; 子选择器1p &gt; span.important &#123; fot-weight: bold; &#125; 这个选择器只与p标签，属于important类的span标签匹配,与下面的span标签不匹配 1&lt;p&gt;This is a paragraph. &lt;em&gt;This is an &lt;span class=\"important\"&gt;important&lt;/span&gt; sentence.&lt;/em&gt;&lt;/p&gt; 这里的span为p的孙子 伪类http://www.w3school.com.cn/css/css_pseudo_classes.asp 锚伪类 1234a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ 更多 http://www.w3school.com.cn/css/css_selector_descendant.asp CSS度量单位 http://www.w3school.com.cn/cssref/css_units.asp CSS颜色 http://www.w3school.com.cn/cssref/css_colors.asp 盒子模型 element: 元素/内容 padding: 内边距 border: 边框 margin: 外边距 边框的属性 属性 说明 border-style 指定显示的边框类型。可能取值包括：none、dotted、dashed、solid、double、groove、ridge、inset、outset、inherit。 border-width 指定边框的宽度，单位通常为像素(px)。 border-color 指定边框颜色。 同时设置多个边框属性时，形式如下 1selector &#123; border: style width color; &#125; eg: 1a &#123; border: dashed 3px red; &#125; 内边距和外边距 内边距(padding)是边框里面的空白区域 外边距(margin)是边框外面的空白区域 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;style type=\"text/css\"&gt; .outer &#123; border: 2px solid black; &#125; .inner &#123; border: 2px dotted black; padding: 15px; margin: 15px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; 工程狮 &lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt; 攻城狮（谐音）工程师，来源于腾讯QQ手机管家于2012年3月1日16:53在发布了一条微博：&lt;br/&gt; 声称腾讯公司一名保安经过一层层技术面试进入了腾讯研究院，成为一名攻城狮（工程师）。&lt;br/&gt; 这种事儿看起来相信很多人的第一反应都是恶搞，不过不久，腾讯老大马化腾亲自出面，核实了这一事件的真实性，并且称这是个“很励志的故事”。&lt;br/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 内容(element)盒子 块式盒子 内嵌盒子 块级元素前后都换行，而内嵌元素的尺寸取决于其包含的内容以及外边距、内边距和边框的设置。CSS提供了属性display来修改元素的默认行为，属性display的可能取值有三个:block、inline和none。 边框显示了在样式表中指定的盒子的尺寸。但文本太多的时候，盒子可能无法容纳，多出来的文本可能会跑到边框的下方。这时，可以通过CSS属性overflow告诉浏览器要如何做。overflow的可能取值包括:visible(默认)、hidden、scroll、auto和inherit。 浮动（修改块级元素的排列方式） 属性float，指出浮动位置，取值：right、left、none 属性clear，消除浮动的影响，取值：none、left、right、both See the Pen 1 by Mr.Ye (@yeshan333) on CodePen. &ensp;&ensp;浮动的p元素移到了页面右边，而第二个段落出现在它的左边。通过将属于right类的元素p的样式属性float设置为right，指出了页面其他元素应沿元素绕排。我们将第三个段落的clear属性设置为both，消除了前面浮动的影响。 如果想要将第二段浮动到第一段的下方，可设置第二段的属性float为right，属性clear设置为right。仅仅设置float属性时，两个段落会并排。 12345678.main &#123; border: 3px solid black; padding: 10px; margin: 10px; float: right; clear: right; width: 33%;&#125;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://dreamer1103.github.io/categories/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://dreamer1103.github.io/categories/CSS/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://dreamer1103.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://dreamer1103.github.io/tags/CSS/"}]},{"title":"Jinja2语法小记","slug":"Jinja2语法小记","date":"2019-01-09T15:26:59.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/01/09/Jinja2语法小记/","link":"","permalink":"https://dreamer1103.github.io/2019/01/09/Jinja2%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/","excerpt":"jinja2模板语法小记 Jinja2模板中文文档 三种常见界定符 表达式{{ ... }} 用于装载字符串、变量、函数调用等 语句{% ... %} 用于装载控制语句，比如if判断、for循环等 注释{# ... #} 用于装载一个注释，模板渲染的时候会被忽略掉","text":"jinja2模板语法小记 Jinja2模板中文文档 三种常见界定符 表达式{{ ... }} 用于装载字符串、变量、函数调用等 语句{% ... %} 用于装载控制语句，比如if判断、for循环等 注释{# ... #} 用于装载一个注释，模板渲染的时候会被忽略掉 变量 在模板中，我们可以使用“.”获取变量的属性 1234user = &#123; 'username' : 'shansan', 'bio': '我佛了',&#125; 如果user为传入模板中的字典变量，则我们可通过”.“获取它的键值。eg：user.usernameuser.username等价于user[‘username’] 我们可以用set标签在模板中定义变量 1&#123;% set navigation &#x3D; [(&#39;&#x2F;&#39;,&#39;Home&#39;),(&#39;&#x2F;about&#39;,&#39;关于我&#39;)] %&#125; 使用endset声明结束 过滤器(filter) 过滤器(filter)是一些可以用来修改和过滤特殊变量值的函数。过滤器和变量用一个竖线“|”（管道符号）隔开，需要参数的过滤器可以像函数一样使用括号传递 eg: 对一个movies列表使用length过滤器获取其长度 1movies|length 下面是Jinja2常用的内置过滤器 过滤器 说明 default(value,default_value,boolean=False) 设置默认值，默认值作为参数传入，别名为d escap(s) 转义HTML文本，别名为e first(seq) 返回序列的第一个元素 last(seq) 返回列表的最后一个元素 length(object) 返回变量的长度 safe(value) 将变量标记为安全，避免转义 wordcount(s) 计算单词数量 过滤器函数的第一个参数表示被过滤的变量值(value)或字符串(s)，即竖线符号左侧的值其他参数可以使用括号传入 测试器(Test) 测试器主要用来判断一个值是否满足某种变量类型,返回布尔值（True or False）的特殊函数语法为：if…is… is的左侧是测试器函数的第一个参数(value) 其他参数可以通过添加括号传入，也可以在右侧使用空格连接 Jinja2常用内置测试器 测试器 说明 callable(object) 判断对象是否可调用 defined(value) 判断变量是否已定义 none(value) 判断变量是否为None number(value) 判断变量是否为数字 string(value) 判断变量是否为字符串 sequence(value) 判断变量是否为序列，比如字符串、列表、元组 iterable(value) 判断变量是否可迭代 mapping(value) 判断变量是否是匹配对象，比如字典 smeas(value,other) 判断变量与other是否指向相同的内存地址 123&#123;% if foo is smeas(bar) %&#125;&#123;# 等价于 #&#125;&#123;% if foo is smeas bar %&#125; 判断foo和bar所以指向的内存地址是否相同 语句 在Jinja2中，语句使用{% ... %}标识在语句结束的地方，必须添加结束标签 if语句使用endif for语句使用endfor 12345&#123;% if user.name &#x3D;&#x3D; &#39;shansan&#39; %&#125; &lt;h1&gt;you are right!&lt;&#x2F;h1&gt;&#123;% else %&#125; &lt;h1&gt;you are wrong!&lt;&#x2F;h1&gt;&#123;% endif %&#125; 123&#123;% for g in ga %&#125; &lt;li&gt;&#123;&#123; g.name &#125;&#125; - &#123;&#123; g.year &#125;&#125;&lt;&#x2F;li&gt;&#123;% endfor %&#125; 不可使用break和continue控制循环的执行 模板局部模板 当多个独立模板中使用到同一块HTML代码时，可以把这部分代码抽离出来，放到局部模板中 局部模板的命名一般以一个下划线开始 使用include标签插入一个局部模板 1&#123;% include &#39;_banner.html&#39; %&#125; 宏 宏，类似于Python中的函数。使用宏可以封装一部分模板代码 一般把宏寄存在即存在名为macros.html或_macros.html文件中 使用macro和endmacro标签声明宏的开始和结束 在开始标签中定义宏的名称和接收的参数 1234567&#123;% macro qux(amount&#x3D;1) %&#125; &#123;% if amount&#x3D;&#x3D;1 %&#125; I am qux. &#123;% elif amount&gt;1 %&#125; We are qux. &#123;% endif %&#125;&#123;% endmacro %&#125; 就像从Python模块中导入函数一样，我们可以使用import导入宏 1&#123;% from &#39;macros.html&#39; import qux %&#125; PS:默认情况下，使用include导入一个局部模板会传递上下文到局部模板中，但使用import却不会 模板继承 模板继承允许我们构建一个包含站点共同元素的基本模板”骨架”，并定义子模版可以覆盖的块 基模板 base.html ** 在基模板中定义的块（block），可以让子模版通过定义同名的块来执行继承操作 ** 块的开始和结束分别使用block和endblock标签,不同的块允许嵌套以下示例代码中使用head、title、styles、content、footer和scripts划分了不同的标签块 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &#123;% block head %&#125; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&#123;% block title %&#125;Template - HelloFlask&#123;% endblock %&#125;&lt;/title&gt; &#123;% block styles %&#125;&#123;% endblock styles %&#125; &#123;% endblock head %&#125;&lt;/head&gt;&lt;body&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=\"&#123;&#123; url_for('index') &#125;&#125;\"&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;main&gt; &#123;% block content %&#125;&#123;% endblock content %&#125; &lt;/main&gt; &lt;footer&gt; &#123;% block footer %&#125; &#123;% endblock footer %&#125; &lt;/footer&gt; &#123;% block scripts %&#125;&#123;% endblock scripts %&#125;&lt;/body&gt;&lt;/html&gt; 子模版 index.html 当在子模版创建同名的块时，会使用字块的内容覆盖父块的内容 这里子模版的content块的内容覆盖了基模板content块的内容 extends 标签必须是模板中的第一个 标签 1234567891011121314&#123;% extends 'base.html' %&#125;&#123;% from 'macros.html' import qux %&#125;&#123;% block content %&#125;&#123;% set name='baz' %&#125;&lt;h1&gt;Template&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"&#123;&#123; url_for('watchlist') &#125;&#125;\"&gt;Watchlist&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Filter: &#123;&#123; foo|musical &#125;&#125;&lt;/li&gt; &lt;li&gt;Global: &#123;&#123; bar() &#125;&#125;&lt;/li&gt; &lt;li&gt;Test: &#123;% if name == 'baz' %&#125;I am baz.&#123;% endif %&#125;&lt;/li&gt; &lt;li&gt;Macro: &#123;&#123; qux(amount=5) &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&#123;% endblock content %&#125; * 如需要向基模板中追加内容，可以使用Jinja2的super()函数 * 如向基模板的styles块追加一行样式 12345678&#123;% block styles %&#125;&#123;&#123; super() &#125;&#125;&lt;style&gt; html&#123; color: red; &#125;&lt;&#x2F;style&gt;&#123;% endblock %&#125; 参考： https://book.douban.com/subject/30310340/ https://www.cnblogs.com/yanzi-meng/p/8342798.html http://docs.jinkan.org/docs/jinja2/templates.html#id21","categories":[{"name":"Flask","slug":"Flask","permalink":"https://dreamer1103.github.io/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://dreamer1103.github.io/tags/Flask/"}]},{"title":"泛型算法-1","slug":"泛型算法-1","date":"2019-01-03T10:41:00.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2019/01/03/泛型算法-1/","link":"","permalink":"https://dreamer1103.github.io/2019/01/03/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-1/","excerpt":"泛型算法-1 泛型算法实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可以用于不同类型的元素的和多种容器类型（不仅包括标准库类型，还包括内置的数组类型），以及其它类型的序列。 ** 大多数算法都定义在头文件algorithm中 ** 算法永远不会执行容器的操作","text":"泛型算法-1 泛型算法实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可以用于不同类型的元素的和多种容器类型（不仅包括标准库类型，还包括内置的数组类型），以及其它类型的序列。 ** 大多数算法都定义在头文件algorithm中 ** 算法永远不会执行容器的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/*算法find*//*- find将范围内中的所有元素与给定值进行比较，返回指向第一个等于给定值的迭代器- 如果范围内无匹配元素，则find返回第二个参数来表示搜索失败 */ void find_value()&#123; //find函数的返回值类型是迭代器类型 //在vector中查找值 int val = 7; vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8&#125;; auto result = find(v.begin(),v.end(),val); cout&lt;&lt;*result&lt;&lt;endl; //在数组中查找值 int nums[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; auto search = find(begin(nums),end(nums),11);//值不存在，返回尾后迭代器 cout&lt;&lt;*search&lt;&lt;endl; &#125; /*算法count*//*- 返回给定值在序列中出现的次数 */ void value_count()&#123; //count函数返回给定值在序列中出现的次数 int a[]=&#123;1,1,1,1,1,2,3,4,5,6&#125;; auto c = count(a,a+10,1); cout&lt;&lt;\"1出现的次数:\"&lt;&lt;c&lt;&lt;endl; &#125;/*算法accumulate*/ /*- accumulate将第三个参数作为求和起点- 注意序列中的元素的类型必须与第三个参数匹配 */ void sum_num()&#123; //accumulate函数用去求给定元素范围内元素的和 vector&lt;int&gt; v=&#123;1,2,3,4,5,6,7,8,9,10&#125;; auto sum = accumulate(v.begin(),v.end(),0); vector&lt;int&gt; v_compare&#123;1,2,3,4,5,6,7,8,9,10,11&#125;; if( equal(v.begin(),v.end(),v_compare.begin()) ) cout&lt;&lt;\"yeah\"&lt;&lt;endl; cout&lt;&lt;sum&lt;&lt;endl;&#125;/*算法fill*//*- 用于确定两个序列中是否保存相同的值- 第二个序列至少与第一个序列一样长 */ void init_fill()&#123; vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8&#125;; fill(v.begin(),v.end(),1);//不要对空容器使用此操作 for(auto a:v) cout&lt;&lt;a&lt;&lt;\" \";&#125;void elimDups(vector&lt;string&gt; &amp;words)&#123; void print(vector&lt;string&gt; v); sort(words.begin(),words.end()); //使用sort算法按字典序重排序列 //unique重排了输入范围，使得每个单词只出现一次， //unique返回指向不重复区域之后一个位置的迭代器 auto end_unique = unique(words.begin(),words.end()); //删除重复元素 words.erase(end_unique,words.end()); print(words);&#125;void print(vector&lt;string&gt; v)&#123; for(auto a:v) cout&lt;&lt;a&lt;&lt;\" \"; cout&lt;&lt;endl;&#125;//定制操作，按照长度重新排vectorbool isShorter(const string &amp;s1,const string &amp;s2)&#123; return s1.size() &gt; s2.size(); &#125; //按长度进行排序 void length_sort(vector&lt;string&gt; &amp;words)&#123; sort(words.begin(),words.end(),isShorter); print(words); //使用算法stable_sort来保持等长元素间的字典序 stable_sort(v.begin(),v.end(),isShorter); print(v); &#125; 向算法传递函数算法谓词 算法谓词即标准库算法传递的参数, 可以指定算法的操作，它是一个可以调用的表达式，其返回结果是一个能用作条件的值 接受谓词参数的算法对输入序列中的元素调用谓词。因此元素类型必须能转换成谓词的参数类型 标准库算法所使用的谓词分为两类：1.一元谓词：它们只接受一个参数2.二元谓词：它们接受两个参数 12345678910111213141516//定制操作，按照长度重新排vectorbool isShorter(const string &amp;s1,const string &amp;s2)&#123; return s1.size() &gt; s2.size(); &#125; //按长度进行排序 void length_sort(vector&lt;string&gt; &amp;words)&#123; sort(words.begin(),words.end(),isShorter); print(words); //使用算法stable_sort来保持等长元素间的字典序 stable_sort(v.begin(),v.end(),isShorter); print(v); &#125; 这里向算法stable_sort传递的第三个参数就是一个谓词 lambda表达式（匿名函数） lambda表达式与其它函数的区别是：lambda表达式可定义在函数内部 基本形式： 1[capture lsit](parameter list) -&gt; return type &#123;function body&#125; capture list(捕获列表): 一个lambda所在函数中的定义的局部变量的列表（通常为空） parameter list(参数列表) return type(返回类型) function body(函数体) ** 我们可以忽略形参列表和返回类型，但是必须永远包含捕获列表和函数体 ** 12 auto f = []&#123;return 44;&#125; ;cout&lt;&lt;f()&lt;&lt;endl;//打印44 上面的向算法stable_sort传递的实参可以改写为,效果还是一样的 1stable_sort(v.begin(), v.end(), [](const string &amp;a,const string s&amp;b)&#123;return a.size()&lt;b.size()&#125;); 捕获列表的使用一个lambda可以出现在一个函数内部，使用其局部变量，但它只能使用那些指明的变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;void biggies(vector&lt;string&gt; &amp;words,vector&lt;string&gt;::size_type sz)&#123; //使用sort算法按字典序重排序列 s sort(words.begin(),words.end()); //unique重排了输入范围，使得每个单词只出现一次， //unique返回指向不重复区域之后一个位置的迭代器 auto end_unique = unique(words.begin(),words.end()); //删除重复元素 words.erase(end_unique,words.end()); //按长度排序,长度相同的按字典序排 stable_sort(words.begin(),words.end(), [](const string &amp;a,const string &amp;b)&#123;return a.size() &lt; b.size();&#125;); //算法find_if返回一个迭代器，这个迭代器指向第一个满足size()&gt;=sz的元素 //这里用到了捕获列表，使用局部变量sz auto wc = find_if(words.begin(),words.end(), [sz](const string &amp;a)&#123;return a.size()&gt;sz; &#125;); //计算满足size &gt;= sz 的元素的个数 auto count = words.end() - wc; cout&lt;&lt;\"the numbers of word longer than \"&lt;&lt;sz&lt;&lt;\": \"&lt;&lt;count&lt;&lt;endl; //打印长度大于等于给定值sz的单词 //算法for_earch接受一个可调用对象，并对输入序列中的每个元素调用此对象 for_each(wc,words.end(),[](const string &amp;s)&#123; cout&lt;&lt;s&lt;&lt;\" \"; &#125;); &#125;int main()&#123; vector&lt;string&gt; words; string str; while(cin&gt;&gt;str) words.push_back(str); for(auto a:words) cout&lt;&lt;a&lt;&lt;\" \"; cout&lt;&lt;endl; biggies(words,6);//打印长度大于或等于给定值的单词 return 0;&#125; ** 捕获列表只用于局部非静态（static）变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字 ** lambada捕获和返回 变量的捕获方式有两种:值捕获、引用捕获 使用引用捕获变量时，必须确保被引用的对象在lambda执行的时候是存在的 lambda捕获的是局部变量，这些变量在函数结束后就不复存在了 我们可以从一个函数返回lambda，函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量类似，此lambda也不能包含引用捕获 使用&amp;、=进行隐式捕获我们可以让编译器根据lambda体中的代码来推断我们要使用哪些变量 &amp;告诉编译器采用引用捕获方式 =告诉编译器采用值捕获方式 混合使用显式捕获和隐式捕获时,显示捕获必须使用与隐式捕获不同的方式 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt; using namespace std;void biggies(vector&lt;string&gt; &amp;words, ostream &amp;os=cout, char c=' ')&#123; //os隐式捕获，c显式捕获 for_each(words.begin(), words.end(), [&amp;, c](const string &amp;s)&#123; os&lt;&lt;s&lt;&lt;c;&#125; ); printf(\"\\n\"); //c隐式捕获，os显示捕获 for_each(words.begin(), words.end(), [=, &amp;os](const string &amp;s)&#123; os&lt;&lt;s&lt;&lt;c;&#125; ); &#125;int main()&#123; vector&lt;string&gt; str; string temp; while(cin&gt;&gt;temp) str.push_back(temp); biggies(str); return 0; &#125; 指定lambda的返回类型 要为一个lambda定义返回类型时，必须使用尾置返回类型 尾置返回类型跟在形参列表后面，并以一个-&gt;符号开头 12auto f = [](int i)-&gt;int&#123; return i+1;&#125;;cout&lt;&lt;f(3)&lt;&lt;endl;//输出结果为：4 可变lambada使用关键字mutable改变一个被捕获变量的值 1234int i=1;auto f = [i]()mutable&#123; return ++i;&#125;;i=0;cout&lt;&lt;f();//输出结果为2 lambda捕获列表 &ensp; 说明 [] 空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有捕获变量后才能使用它们 [names] names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝 [&amp;] 隐式捕获列表，采用隐式捕获方式 [=] 隐式捕获列表，采用值捕获方式 [&amp;, identifier_list] identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量，这些变量采用值捕获方式。任何隐式捕获的变量都采用引用方式捕获 [=, identifier_list] identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量，这些变量采用引用捕获方式，且变量名字前必须使用&amp;。任何隐式捕获的变量都采用值方式捕获","categories":[{"name":"CPP","slug":"CPP","permalink":"https://dreamer1103.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://dreamer1103.github.io/tags/CPP/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-03-06T06:35:49.835Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://dreamer1103.github.io/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 12345678# Sitetitle: 你的站点名subtitle:description: 站点简介keywords:author: 作者名language: zh-cntimezone: 部署 123456deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） 1234567backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121# site name# 站点名 【改】prefixName: さくら荘そのsiteName: hojun# favicon and site master avatar# 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】favicon: /images/favicon.icoavatar: /img/custom/avatar.jpg# 站点url 【改】url: https://sakura.hojun.cn# 站点介绍（或者说是个人签名）【改】description: Live your life with passion! With some drive!# 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpgcdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6# 开启pjax 【选】pjax: 1# 站点首页的公告信息 【改】notice: hexo-Sakura主题已经开源，目前正在开发中...# 懒加载的加载中图片 【选】lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg# 站点菜单配置 【选】menus: 首页: &#123; path: /, fa: fa-fort-awesome faa-shake &#125; 归档: &#123; path: /archives, fa: fa-archive faa-shake, submenus: &#123; 技术: &#123;path: /categories/技术/, fa: fa-code &#125;, 生活: &#123;path: /categories/生活/, fa: fa-file-text-o &#125;, 资源: &#123;path: /categories/资源/, fa: fa-cloud-download &#125;, 随想: &#123;path: /categories/随想/, fa: fa-commenting-o &#125;, 转载: &#123;path: /categories/转载/, fa: fa-book &#125; &#125; &#125; 清单: &#123; path: javascript:;, fa: fa-list-ul faa-vertical, submenus: &#123; 书单: &#123;path: /tags/悦读/, fa: fa-th-list faa-bounce &#125;, 番组: &#123;path: /bangumi/, fa: fa-film faa-vertical &#125;, 歌单: &#123;path: /music/, fa: fa-headphones &#125;, 图集: &#123;path: /tags/图集/, fa: fa-photo &#125; &#125; &#125; 留言板: &#123; path: /comment/, fa: fa-pencil-square-o faa-tada &#125; 友人帐: &#123; path: /links/, fa: fa-link faa-shake &#125; 赞赏: &#123; path: /donate/, fa: fa-heart faa-pulse &#125; 关于: &#123; path: /, fa: fa-leaf faa-wrench , submenus: &#123; 我？: &#123;path: /about/, fa: fa-meetup&#125;, 主题: &#123;path: /theme-sakura/, fa: iconfont icon-sakura &#125;, Lab: &#123;path: /lab/, fa: fa-cogs &#125;, &#125; &#125; 客户端: &#123; path: /client/, fa: fa-android faa-vertical &#125; RSS: &#123; path: /atom.xml, fa: fa-rss faa-pulse &#125;# Home page sort type: -1: newer first，1: older first. 【非】homePageSortType: -1# Home page article shown number) 【非】homeArticleShown: 10# 背景图片 【选】bgn: 8# startdash面板 url, title, desc img 【改】startdash: - &#123;url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png&#125; - &#123;url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg&#125; - &#123;url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg&#125;# your site build time or founded date# 你的站点建立日期 【改】siteBuildingTime: 07/17/2018# 社交按钮(social) url, img PC端配置 【改】social: github: &#123;url: http://github.com/honjun, img: /img/social/github.png&#125; sina: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png&#125; wangyiyun: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png&#125; zhihu: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png&#125; email: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg&#125; wechat: &#123;url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png&#125;# 社交按钮(msocial) url, img 移动端配置 【改】msocial: github: &#123;url: http://github.com/honjun, fa: fa-github, color: 333&#125; weibo: &#123;url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39&#125; qq: &#123;url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe&#125;# 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg# 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4# 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true# Valine评论配置【改】valine: truev_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHszv_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 12345678910111213141516171819#category# 按分类名创建技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg#tag# 标签名即是标题悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： 123456789---title: commentdate: 2018-12-20 23:13:48keywords: 留言板description: comments: true# 在这里配置单页面头部图片，自定义替换哦~photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg--- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） 123456789101112131415161718192021222324252627282930---layout: bangumititle: bangumicomments: falsedate: 2019-02-10 21:32:48keywords:description:bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。--- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） 1234567891011121314151617181920212223242526272829303132333435363738394041424344---layout: linkstitle: links# 创建日期，可以改下date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改keywords: 友人帐 description: # true/false 开启/关闭评论comments: true # 页面头部图片，自定义修改photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像--- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： 1&#123;% bili video_id [page] %&#125; 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： 1&#123;% fb_img src [caption] %&#125; 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://dreamer1103.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web , 悦读","slug":"web-悦读","permalink":"https://dreamer1103.github.io/tags/web-%E6%82%A6%E8%AF%BB/"}],"author":"hojun"},{"title":"Github+jsDelivr+PicGo 打造稳定快速、高效免费图床","slug":"Github+jsDelivr+PicGo 打造稳定快速、高效免费图床","date":"2018-12-11T12:16:01.000Z","updated":"2019-12-25T03:12:27.188Z","comments":true,"path":"2018/12/11/Github+jsDelivr+PicGo 打造稳定快速、高效免费图床/","link":"","permalink":"https://dreamer1103.github.io/2018/12/11/Github+jsDelivr+PicGo%20%E6%89%93%E9%80%A0%E7%A8%B3%E5%AE%9A%E5%BF%AB%E9%80%9F%E3%80%81%E9%AB%98%E6%95%88%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"Github+jsDelivr+PicGo 打造稳定快速、高效免费图床 – 前言图床是个啥东西就不用过多介绍了，先来对比一下各路图床： 微博图床：以前用的人比较多，从2019年4月开始开启了防盗链，凉凉 SM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧 其他小众图床：随时有挂掉的风险 Imgur等国外图床：国内访问速度太慢，随时有被墙的风险 大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，容量限制，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说） 因此，GitHub 图床是个不错的选择，利用 jsDelivr CDN 加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo 工具一键上传，操作简单高效，GitHub 和 jsDelivr 都是大厂，不用担心跑路问题，不用担心速度和容量问题，而且完全免费，可以说是目前免费图床的最佳解决方案！ – 新建GitHub仓库登录/注册GitHub，新建一个仓库，填写好仓库名，仓库描述，根据需求选择是否为仓库初始化一个README.md描述文件 – 生成一个Token在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页 – 配置PicGo前往下载PicGo，安装好后开始配置图床 设定仓库名：按照【用户名/图床仓库名】的格式填写 设定分支名：【master】 设定Token：粘贴之前生成的【Token】 指定存储路径：填写想要储存的路径，如【ITRHX-PIC/】，这样就会在仓库下创建一个名为 ITRHX-PIC 的文件夹，图片将会储存在此文件夹中 设定自定义域名：它的作用是，在图片上传后，PicGo 会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接，并放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为【https://cdn.jsdelivr.net/gh/用户名/图床仓库名 】，上传完毕后，我们就可以通过【https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径 】加速访问我们的图片了，比如上图的图片链接为：https://cdn.jsdelivr.net/gh/TRHX/ImageHosting/ITRHX-PIC/A27/08.png 关于 jsDelivr 具体是如何引用资源的可以参考我的另一篇博客：《免费CDN：jsDelivr+Github》 – 进行高效创作配置好PicGo后，我们就可以进行高效创作了，将图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的，此外PicGo还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://dreamer1103.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://dreamer1103.github.io/tags/linux/"}],"author":"xingyu1103"},{"title":"Linux定时备份MySQL数据库","slug":"Linux定时备份MySQL数据库","date":"2018-12-11T12:16:01.000Z","updated":"2020-03-06T06:36:16.954Z","comments":true,"path":"2018/12/11/Linux定时备份MySQL数据库/","link":"","permalink":"https://dreamer1103.github.io/2018/12/11/Linux%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BDMySQL%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"Linux定时备份MySQL数据库一开始没想到我会弄这个，以前觉得数据库一般很安全不需要定时备份。但是前几天的经历还是让我意识到了定时备份数据库的重要性，一个作业的数据库莫名其妙没了，后面通过快照回滚找回来了。后来就想到定时备份数据库了，经过一番折腾终于完成了这个功能。接下来就详细记一下 Linux定时备份MySQL数据库 的教程。 系统环境 CentOS 7.6.1810 MySQL 5.7.26 Step 1：创建目录1234### 创建定时脚本目录mkdir -p &#x2F;home&#x2F;backup&#x2F;mysql&#x2F;shell### 创建sql文件放置目录mkdir -p &#x2F;home&#x2F;backup&#x2F;mysql&#x2F;sql Step 2：编写备份脚本在我们上一步新建的 /home/backup/mysql/shell 下 新建一个 backup.sh,内容如下 1234567891011### 数据库用户db_user&#x3D;&quot;root&quot;### 数据库用户密码db_passwd&#x3D;&quot;*******&quot;### 要备份的数据库名称db_name&#x3D;&quot;example&quot;### 备份出来的sql名称name&#x3D;&quot;example-&quot;$(date &quot;+%Y-%m-%d-%H-%M-%S&quot;) ###前面路径是mysql绝对路径，后面&#x2F;home&#x2F;backup&#x2F;mysql&#x2F;sql&#x2F;是要备份到的目录&#x2F;www&#x2F;server&#x2F;mysql&#x2F;bin&#x2F;mysqldump -u$db_user -p$db_passwd $db_name&gt;&#x2F;home&#x2F;backup&#x2F;mysql&#x2F;sql&#x2F;$name.sql Step 3：给脚本添加可执行权限这一步很重要，不给backup.sh添加可执行权限，定时任务是无法完成备份的。 1chmod +x backup.sh Step 4： 将脚本添加到定时任务首先使用如下命令编辑定时任务 1crontab -e 编辑的内容如下 12###每一分钟执行一次后面的脚本(设置的周期短易于观察）*&#x2F;1 * * * * &#x2F;home&#x2F;backup&#x2F;mysql&#x2F;shell&#x2F;backup.sh Step 5 ：查看执行情况去我们制定的备份目录/home/backup/mysql/sql查看是否输出了sql文件 可以看到每一分钟都输出了sql文件，让我们看看里面的内容 确实看到了user表的数据，至此也就大功告成 附：crontab 定时任务时间格式设定crontab 文件的格式{minute} {hour} {day-of-month} {month} {day-of-week} {full-path-to-shell-script} minute: 区间为 0 – 59 hour: 区间为0 – 23 day-of-month: 区间为0 – 31 month: 区间为1 – 12. 1 是1月. 12是12月. Day-of-week: 区间为0 – 7. 周日可以是0或7. 示例 */1 * * * * 每分钟运行一次命令 0 * * * * 每小时执行 0 0 * * * 每天执行 0 0 * * 0 每周执行 0 0 1 * * 每月执行","categories":[{"name":"mysql","slug":"mysql","permalink":"https://dreamer1103.github.io/categories/mysql/"}],"tags":[{"name":"mysql , linux","slug":"mysql-linux","permalink":"https://dreamer1103.github.io/tags/mysql-linux/"}],"author":"xiangyu1103"},{"title":"Keep on moving ！","slug":"Keep-on-moving-！","date":"2018-11-26T16:35:22.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/11/27/Keep-on-moving-！/","link":"","permalink":"https://dreamer1103.github.io/2018/11/27/Keep-on-moving-%EF%BC%81/","excerpt":"","text":"比赛终于完了！又可以安心打代码看书了emmmmmmm","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://dreamer1103.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"IO类型","slug":"IO类型","date":"2018-11-21T16:13:54.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/11/22/IO类型/","link":"","permalink":"https://dreamer1103.github.io/2018/11/22/IO%E7%B1%BB%E5%9E%8B/","excerpt":"IO库** IO库设施: ** istream类型:提供输入操作 ostream类型:提供输出操作 cin:一个istream对象，从标准输入读取数据 cout:一个ostream对象，从标准输出写入数据 cerr:一个ostream对象，通常用于输出程序错误信息，写入到标准错误 &gt;&gt;运算符:用来从一个istream对象读取输入数据 &lt;&lt;运算符:用来向一个ostream对象写入数据 getline函数:从一个给定的istream读取一行数据，存入一个给定的string对象中","text":"IO库** IO库设施: ** istream类型:提供输入操作 ostream类型:提供输出操作 cin:一个istream对象，从标准输入读取数据 cout:一个ostream对象，从标准输出写入数据 cerr:一个ostream对象，通常用于输出程序错误信息，写入到标准错误 &gt;&gt;运算符:用来从一个istream对象读取输入数据 &lt;&lt;运算符:用来向一个ostream对象写入数据 getline函数:从一个给定的istream读取一行数据，存入一个给定的string对象中 IO类 头文件 IO库类型 iostream istream,wistream从流读取数据ostream,wostream向流写入数据iostream,wiostream读写流 fstream ifstream,wistream从文件读取数据ofstream,wofstream向文件写入数据fstream,wfstream读写文件 sstream istringstream,wistringstream从string读取数据ostringstream,wostringstream向string写入数据stringstream,wstringstream读写string IO对象没有拷贝或赋值 定义函数时不能将形参设置为流类型 进行IO操作的函数通常使用引用方式传递和返回流 因为读写一个IO对象会改变其状态，因此传递和返回的引用不能是const类型的 一个流一旦发生错误，其后续的IO操作都会失败 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;istream&amp; read_print(istream &amp;s)&#123; int score; while(s&gt;&gt;score) &#123; cout&lt;&lt;score&lt;&lt;endl; &#125; s.clear();//流复位，清楚所有错误标志位 return s;&#125;int main()&#123; read_print(cin); cout&lt;&lt;\"shansan\"; return 0;&#125; 输出缓冲管理cout&lt;&lt;&quot;shansan&quot;文本串可能立即打印出来，但也有可能被操作系统保存在操作系统的缓冲区中，随后再打印。缓冲机制的存在可以让操作系统将程序的多个输出操作组合成单一的系统级写操作由于设备写操作可能很耗时间，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的便利 ** 使用操纵符刷新缓冲区 ** endl:完成换行机制并且刷新缓冲区 ends:仅刷新缓冲区 flush:仅刷新缓冲区 程序崩溃，输出缓冲区不会刷新 文件IOhttps://shansan.top/2018/10/22/%E5%9D%91%E4%BA%BA%E7%9A%84C++-2/#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6-amp-amp-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6头文件定义了三个文件类型来支持文件IO ifstream:从文件读取数据 ofstream:向文件写入数据 fstream:读和写操作都能进行 每一个文件流对象都定义了一个名为open的成员函数，它完成了一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式一旦一个文件流已经打开，它就保持与对应文件的关联。对一个已经打开的文件流调用open会失败，并会导致failbit被置位，随后试图使用文件流的操作都会失败 ** ifstream、ofstream、fstream对象上的操作，以下操作都适用 操作 说明 fstream file 创建一个未绑定的文件流 fstream file(file_name) 创建一个fstream对象，并打开名字为file_name的文件。file_name可以是一个指向C风格的字符串，也可以是一个string类型 fstream file(file_name,mode) mode为指定的打开模式 fstream.close() 关闭与fstream绑定的文件 fstream.is_open() 返回一个bool值，指出与fstream关联的文件是否成功被打开且尚未被关闭 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt; using namespace std;void write()&#123; ofstream file; file.open(\"shansan.txt\"); //等价于fstream file(\"shanshan.txt\"); //像文件写入数据 file&lt;&lt;\"shansan\"&lt;&lt;endl; file&lt;&lt;\"shansan.top\"&lt;&lt;endl; file&lt;&lt;\"yeshan333.github.io\"&lt;&lt;endl; file.close();&#125;void read_print()&#123; string buffer; ifstream read_file(\"shansan.txt\"); vector&lt;string&gt; v; while(getline(read_file,buffer))//每次从read_file读取一行给buffer v.push_back(buffer);//将buffer存到vector对象v中 for(auto temp:v) cout&lt;&lt;temp&lt;&lt;endl; &#125; int main()&#123; write(); read_print(); return 0;&#125; 文件模式每一个流都有一个关联的文件模式，用来指出如何使用文件。每一个文件流都定义了一个默认的文件模式 与ifstream关联的文件默认以in模式打开 与ofstream关联的文件默认以out模式打开 与fstream关联的文件默认以in和out模式打开 文件模式 说明 in 以读方式打开文件 out 以写方式打开文件 app 每次写操作前均定位到文件末尾 ate 打开文件后立即定位到文件末尾 trunc 截断文件 binary 以二进制方式进行IO","categories":[{"name":"CPP","slug":"CPP","permalink":"https://dreamer1103.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://dreamer1103.github.io/tags/CPP/"}]},{"title":"二分查找","slug":"二分查找","date":"2018-11-18T16:30:43.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/11/19/二分查找/","link":"","permalink":"https://dreamer1103.github.io/2018/11/19/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二分查找算法百度百科算法效率O(log&lt;sub&gt;2&lt;/sub&gt;n)（对数时间）输入为一个有序的元素序列，如果要查找的元素包含在列表中，二分查找返回其位置，否则返回null 二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt;a[n/2],则只要在&gt;数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x. ** 仅当列表是有序的时候，二分查找才是有效的 ** python实现123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-# binary_searchdef binary_search(list_1, item): low = 0 high = len(list_1)-1 while low &lt;= high: '''使用 // 整除运算符可以不用int进行类型转换''' #每次都检查中间的元素 mid = (low + high)/2 guess = list_1[int(mid)] if guess == item: return int(mid)#返回所在位置的索引 if guess &lt; item: #猜的数字小了，修改low low = mid+1 if guess &gt; item: #猜的数字大了，修改high high = mid-1 return Nonedef main(): list_2 = [1,2,3,4,5,6,7,8,9] print(binary_search(list_2, 8)) print(binary_search(list_2, 10))main() C++实现1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;int binary_search(int a[9],int n,int x)//n为元素个数 &#123; int mid; int high,low=0; int guess; high = n-1;//数组下标从0开始 while(low &lt;= high) &#123; mid = (high+low)/2; guess = a[mid]; if(guess == x) return mid; if(guess &gt; x) high = mid-1; if(guess &lt; x) low = mid+1; &#125; return -1;&#125;int main()&#123; int temp; int a[9] = &#123;1,2,3,4,5,6,7,8,9&#125;; cout&lt;&lt;sizeof(a)/sizeof(int)&lt;&lt;endl; cout&lt;&lt;typeid(sizeof(a)/sizeof(int)).name()&lt;&lt;endl; temp = binary_search(a,sizeof(a)/sizeof(int),5); cout&lt;&lt;temp&lt;&lt;endl; return 0; &#125; 类型名获取使用头文件typeinfo下的typeid(parameter).name()获取类型名","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://dreamer1103.github.io/categories/Algorithm/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://dreamer1103.github.io/tags/CPP/"},{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/tags/Python/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://dreamer1103.github.io/tags/Algorithm/"}]},{"title":"精度(precision)控制","slug":"精度-precision-控制","date":"2018-11-06T15:50:56.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/11/06/精度-precision-控制/","link":"","permalink":"https://dreamer1103.github.io/2018/11/06/%E7%B2%BE%E5%BA%A6-precision-%E6%8E%A7%E5%88%B6/","excerpt":"C++输出精度（precision）控制,格式化输出使用cout对象的成员 setprecision() setf() width() fill() flags(ios::fixed)","text":"C++输出精度（precision）控制,格式化输出使用cout对象的成员 setprecision() setf() width() fill() flags(ios::fixed) 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int main()&#123; double a=3.1415926; double c=66.666666; cout.precision(3); //控制输出流显示的有效数字个数 cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;endl; cout.width(8); //控制输出宽度 cout.setf(ios::right); //设置对齐方式 cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;endl; cout.setf(ios::right); cout.fill('#'); //设置填充字符 cout.width(8); cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;endl; cout.flags(ios::fixed); //flags(ios::fixed)和precision()配合使用控制精度 cout.precision(4); cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 使用头文件iomanip中的setprecision()和setiosflags(ios::fixed)进行精度控制1234567891011121314#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; double e = 2.7182818; cout&lt;&lt;setprecision(3)&lt;&lt;e&lt;&lt;endl; cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;endl; cout&lt;&lt;setprecision(3)&lt;&lt;e&lt;&lt;endl; return 0;&#125; 参考自：https://blog.csdn.net/yanglingwell/article/details/49507463","categories":[{"name":"CPP","slug":"CPP","permalink":"https://dreamer1103.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://dreamer1103.github.io/tags/CPP/"}]},{"title":"Scrapy爬虫框架","slug":"Scrapy爬虫框架","date":"2018-10-31T15:13:19.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/10/31/Scrapy爬虫框架/","link":"","permalink":"https://dreamer1103.github.io/2018/10/31/Scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/","excerpt":"","text":"网络爬虫框架scrapy（配置型爬虫） 什么是爬虫框架？ 爬虫框架是实现爬虫功能的一个软件结构和功能组件集合 爬虫框架是个半成品，帮助用户实现专业网络爬虫 scrapy框架结构(“5+2”结构) spider: 解析downloader返回的响应（Response） 产生爬取项（scraped item） 产生额外的爬去请求（Request）需要用户编写配置代码 engine(引擎): 控制所有模块之间的数据流 根据条件触发事件不需要用户修改 scheduler(调度器): 对所有爬取请求进行调度处理不需要用户修改 downloader(下载器): 根据请求下载网页不需要用户修改 item pipelines(): 以流水线处理spider产生的爬取项 由一组操作顺序组成，类似流水线，每个操作是一个Item Pipeline类型 可能操作包括：清理、检验和查重爬取项中的HTML数据，将数据存储到数据库中需要用户编写配置代码 downloader middleware(中间件): 目的：实施engine、scheduler和downloader之间进行用户可配置的控制 功能：修改、丢弃、新增请求或响应用户可以编写配置代码 spider middleware(中间件): 目的：对请求和爬去项的再处理 功能：修改、丢弃、新增请求或爬取项用户可以编写配置代码 数据流 1.Engine从Spider处获得爬取请求(Request) 2.Engine将爬取请求转发给Scheduler,用于调度 3.Engine从Scheduler处获得下一个爬取的请求 4.Engine将爬取请求通过中间件发送给Downloader 5.爬取网页后，Downloader形成响应(Response)，通过中间件(Middleware)发给Engine 6.Engine将收到的响应通过中间件发送给Spider处理 7.Spider处理响应后产生爬取项（scraped item）和新的爬取请求(Requests)给Engine 8.Engine将爬取项发送给Item Pipeline(框架出口) 9.Engine将爬取请求发送给Scheduler Engine控制各模块数据流，不间断从Scheduler处获得爬取请求，直到请求为空 框架入口：Spider的初始爬取请求 框架出口：Item Pipeline scrapy命令行格式 scrapy &lt;command&gt; [options] [args] ** 常用命令 ** 命令 说明 格式 startproject 创建一个新工程 scrapy startproject [dir] genspider 创建一个爬虫 scrapy genspider [options] [domain] settings 获得爬虫配置信息 scrapy settings [options] crawl 运行一个爬虫 scrapy crawl list 列出工程中所有的爬虫 scrapy list shell 启动URL调试命令行 scrapy shell [url] demohttps://python123.io/ws/demo.html创建工程scrapy startproject python123demo 创建爬虫scrapy genspider demo python123.io //生成了一个名为demo的spider //在spider目录下增加代码文件demo.py（该文件也可以手工生成） ** demo.py文件 ** 1234567891011# -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider): name = 'demo' allowed_domains = ['python123.io'] start_urls = ['http://python123.io/'] def parse(self, response): pass 配置产生的spider爬虫123456789101112131415# -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider): name = 'demo' #allowed_domains = ['python123.io'] start_urls = ['http://python123.io/ws/demo.html'] def parse(self, response): #存储文件名demo.html file_name = response.url.split('/')[-1] with open(file_name,\"wb\") as f: f.write(response.body) self.log('Saved file %s' % file_name)#日志 *** 另一个版本 ** 123456789101112131415161718192021# -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider): name = 'demo' #allowed_domains = ['python123.io'] #start_urls = ['http://python123.io/ws/demo.html'] def start_requests(self): urls = [ 'http://python123.io/ws/demo.html' ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): #存储文件名demo.html file_name = response.url.split('/')[-1] with open(file_name,\"wb\") as f: f.write(response.body) self.log('Saved file %s' % file_name)#日志 运行爬虫scrapy crawl demoScrapy爬虫数据类型 Request类 Response类 Item类 Request类class scrapy.http.Request() Request对象表示一个HTTP请求 由Spider生成，由Downloader执行 属性 方法 .url Requests对应的请求URL地址 .method 对应的请求方法，’GEt’、’POST’等 .headers 字典类型风格的请求头 .body 请求内容主体，字符串类型 .meta 用户添加的扩展信息，在Scrapy内部模块间传递信息使用 .copy 复制该请求 Response类class scrapy.http.Response() Response对象表示一个HTTp响应 由Downloader生成，由Spider处理 属性或方法 说明 .url Response对应的URL地址 .status HTTP状态码，默认是200 .headers Response对应的头部信息 .body Response对应的内容信息，字符串类型 .flags 一组标记 .request 产生Response类型对应的Request对象 .copy() 复制该响应 Item类class scrapy.item.Item() Item对象表示一个从HTML页面中提取的信息内容 由Spider生成，由Item Pipeline处理 Item类似字典类型，可以按照字典类型操作 Scrapy爬虫的使用步骤 创建一个工程和Spider模板 编写Spider 编写Item Pipeline 优化配置策略 scrapy爬虫信息提取方法 Beautifui Soup lxml re XPath Selector CSS Selector","categories":[{"name":"Scrapy","slug":"Scrapy","permalink":"https://dreamer1103.github.io/categories/Scrapy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/tags/Python/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://dreamer1103.github.io/tags/Scrapy/"}]},{"title":"HTML试水","slug":"HTML试水","date":"2018-10-30T15:39:10.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/10/30/HTML试水/","link":"","permalink":"https://dreamer1103.github.io/2018/10/30/HTML%E8%AF%95%E6%B0%B4/","excerpt":"一级标题 二级标题","text":"一级标题 二级标题 倚天屠龙记张无忌这是另一段 锚点这是我的个人博客这是我的个人博客，新标签页打开 邮箱联系我 图像** img是自关标记，不需要结束标记 ** 文本这里是粗体 这里是斜体 what 这里还是斜体 插入字体，下划线 删除线 ~~~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113下标&amp;&amp;上标H&lt;sub&gt;2&lt;&#x2F;sub&gt;O&lt;sub&gt;2&lt;&#x2F;sub&gt;嗯&lt;sup&gt;我飘了&lt;&#x2F;sup&gt;&lt;code&gt;#include&lt;stdio.h&gt;int main()&#123; printf(&quot;wocao!&quot;);&#125;&lt;&#x2F;code&gt;正常字&lt;small&gt;小号字&lt;&#x2F;small&gt;&lt;q&gt;短引用，双引号包围&lt;&#x2F;q&gt;&lt;blockquote&gt;长引用土地是以它的肥沃和收获而被估价的；才能也是土地，不过它生产的不是粮食，而是真理。如果只能滋生瞑想和幻想的话，即使再大的才能也只是砂地或盐池，那上面连小草也长不出来的。 —— 别林斯基&lt;&#x2F;blockquote&gt;22222222222222222222222222222## 表格 &lt;table&gt;...&lt;&#x2F;table&gt;:定义表格 &lt;th&gt;...&lt;&#x2F;th&gt;:定义表格的标题栏（文字加粗体） &lt;tr&gt;...&lt;&#x2F;tr&gt;:定义表格的行 &lt;td&gt;...&lt;&#x2F;td&gt;:定义表格的列&lt;table border&#x3D;&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;row 1, cell 1&lt;&#x2F;td&gt;&lt;td&gt;row 1, cell 2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;row 2, cell 1&lt;&#x2F;td&gt;&lt;td&gt;row 2, cell 2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;### 跨列表格&lt;table border&#x3D;&quot;1&quot;&gt;&lt;tr&gt; &lt;th&gt;姓名&lt;&#x2F;th&gt; &lt;th colspan&#x3D;&quot;2&quot;&gt;电话&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;tr&gt; &lt;td&gt;shansan&lt;&#x2F;td&gt; &lt;td&gt;1329441308&lt;&#x2F;td&gt; &lt;td&gt;164354491&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;table&gt;&lt;h3&gt;跨行表格&lt;&#x2F;h3&gt;&lt;table border&#x3D;&quot;1&quot;&gt;&lt;tr&gt; &lt;th&gt;姓名&lt;&#x2F;th&gt; &lt;td&gt;shansan&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt; &lt;th rowspan&#x3D;&quot;2&quot;&gt;电话&lt;&#x2F;th&gt; &lt;td&gt;1329441308&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt; &lt;td&gt;164354491&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;## syntax&#96;&#96;&#96;html# HTML试水&lt;h1&gt; 一级标题 &lt;&#x2F;h1&gt;&lt;h2&gt; 二级标题 &lt;&#x2F;h2&gt;&lt;!-- more --&gt;&lt;p&gt;倚天屠龙记&lt;&#x2F;p&gt;&lt;p&gt;张无忌&lt;&#x2F;p&gt;&lt;p&gt;这是另一段&lt;&#x2F;p&gt;## 锚点&lt;a href &#x3D; &quot;https:&#x2F;&#x2F;shansan.top&quot;&gt;这是我的个人博客&lt;&#x2F;a&gt;&lt;a href &#x3D; &quot;https:&#x2F;&#x2F;shansan.top&quot; target&#x3D;&quot;_blank&quot;&gt;这是我的个人博客，新标签页打开&lt;&#x2F;a&gt;&lt;a href&#x3D;&quot;mailto:1329441308@qq.com&quot; target&#x3D;&quot;_top&quot;&gt;邮箱联系我&lt;&#x2F;a&gt;# 图像** img是自关标记，不需要结束标记 **&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png&quot; width&#x3D;&quot;500&quot; height&#x3D;&quot;500&quot;&gt;## 文本&lt;b&gt;这里是粗体&lt;&#x2F;b&gt;&lt;i&gt;这里是斜体&lt;&#x2F;i&gt;&lt;strong&gt;what&lt;&#x2F;strong&gt;&lt;em&gt;这里还是斜体&lt;&#x2F;em&gt;&lt;ins&gt;插入字体，下划线&lt;&#x2F;ins&gt;&lt;del&gt;删除线&lt;&#x2F;del&gt;~~~ 还是删除线 下标&amp;&amp;上标H2O2 嗯我飘了 #includeint main(){ printf(\"wocao!\");} 正常字小号字 短引用，双引号包围 长引用 土地是以它的肥沃和收获而被估价的；才能也是土地，不过它生产的不是粮食，而是真理。 如果只能滋生瞑想和幻想的话，即使再大的才能也只是砂地或盐池，那上面连小草也长不出来的。 —— 别林斯基 22222222222222222222222222222 表格 row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2 跨列表格 姓名 电话 shansan 1329441308 164354491 跨行表格 姓名 shansan 电话 1329441308 164354491 ``` ---","categories":[{"name":"HTML","slug":"HTML","permalink":"https://dreamer1103.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://dreamer1103.github.io/tags/HTML/"}]},{"title":"丘一丘正则表达式","slug":"丘一丘正则表达式","date":"2018-10-17T17:51:46.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/10/18/丘一丘正则表达式/","link":"","permalink":"https://dreamer1103.github.io/2018/10/18/%E4%B8%98%E4%B8%80%E4%B8%98%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"正则表达式(regular expression,regex,RE) 正则表达式是一种用来简洁表达一组字符串的表达式 正则表达式是一种通用的字符串表达框架 正则表达式是一种针对字符串表达“简洁”和“特征”思想的工具 正则表达式可以用来判断某字符串的特征归属","text":"正则表达式(regular expression,regex,RE) 正则表达式是一种用来简洁表达一组字符串的表达式 正则表达式是一种通用的字符串表达框架 正则表达式是一种针对字符串表达“简洁”和“特征”思想的工具 正则表达式可以用来判断某字符串的特征归属 正则表达式常用操作符 操作符 说明 实例 . 表示任意单个字符 py. 可以匹配pyc,pyy,py!等等 [ ] 字符集，对单个字符给出取值范围 [abc]可以匹配a或b或c；[0-9a-zA-z\\_]可以匹配一个数字、一个字母或者一个下划线 [^ ] 非字符集，对单个字符给出排除范围 [^abc]可以匹配非a或非b或非c的单个字符 * 前一个字符0次或多次扩展 abc* 可以匹配ab、abc、abcc、abccc等等 + 前一个字符的1次或多次扩展 abc+可以匹配abc、abcc、abccc等等 ? 前一个字符0次或1次扩展 abc?可以匹配ab、abc &#124; 左右表达式任意一个 abc&#124;def表示abc、def {m} 扩展前一个字符m次 ab{2}c匹配abbc {m,n} 扩展前一个字符m至n次数（含n） ab{1，2}c可以匹配abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头,^\\d表示必须以数字开头 $ 匹配字符串结尾 abc表示abc且在一个字符串的结尾、\\d$白哦是必须以数字结尾 ( ) 分组标记,内部只能使用&#124;操作符 (abc&#124;def)表示abc、def \\d 可以匹配一个数字，相当于[0-9] \\d{3}表示匹配3个数字，如010 \\w 可以匹配一个字母或者数字或者下划线，相当于[a-zA-Z0-9_] \\w\\w\\d可以匹配’py3’ \\s 可以匹配一个空格（也包括Tab等空白字符） \\s+表示至少有一个空格，如’ ‘、’ ‘ 精确匹配在正则表达式中，如果直接给出字符，就是精确匹配 ‘pyt’ 匹配’pyt’ ‘00\\d’ 可以匹配’007’ ‘\\w\\d’ 可以匹配’!5’ ‘ye.’ 可以匹配’yes’ ‘(P&#124;p)python’ 可以匹配’Python’、’python’ 高阶精确匹配,经典实例 ^[A-Za-z]+$ 匹配由26个英文字母组成的字符串,如’abrg’、’abgsfsfga’ [a-zA-Z\\_][0-9a-zA-Z\\_]* 可以匹配由字母或者下划线开头、后接任意一个由字母、数字或者下划线组成的字符串，也就是python的合法变量 ^-?\\d+$ 匹配整数形式的字符串 ^[0-9][1-9][0-9]$ 匹配正整数形式的字符串 [1-9]\\d{5} 中国境内邮政编码,6位 [\\u4e00-\\u9fa5] 匹配中文字符 \\d{3}-\\d{8}&#124;\\d{4}-\\d{7} 国内电话号码,010-68913536 python正则表达式模块，（Re模块） re是python的标准库，主要用于字符串匹配 re库采用raw string类型(原生字符串类型)表示正则表达式，例如r&#39;[1-9]\\d{5}&#39;,raw string是不包含对转义符再次转义的字符串 re库也可以采用string类型表示正则表达，但是较为繁琐，例如&#39;[1-9]\\\\d{5}&#39; re库功能函数 函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 re.match() 从一个字符串的开始位置起匹配正则表达式，返回match对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.split() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.finditer 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 re.sub() 在字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 1. re.search(pattern,string,flags=0)在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 pattern:正则表达式的字符串或原生字符串表示 string:待匹配字符串 flags： 正则表达式使用时的控制标记 常用标记 说明 re.I&ensp;re.IGNORECASE 忽略正则表达式的大小写，[A-Z]能够匹配小写字符 re.M&ensp;re.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当做匹配开始 re.s&ensp;re.DOTALL 正则表达式中的.操作符能够匹配所有字符串，默认匹配除换行外的所有字符串 2. re.match(pattern,string,flags=0)从一个字符串的开始位置起匹配正则表达式，返回match对象 pattern:正则表达式的字符串或者原生字符串表示 string:待匹配字符串 flags:正则表达式使用时的控制标记 3. re.findall(pattern,string,flags=0)搜索字符串，以列表类型返回全部能匹配的字符串 4. re.split(pattern,string,maxsplit=0,flags=0)将一个字符串按照正则匹配结果进行分割，返回列表类型 maxsplt:最大分割数，剩余部分作为最后一个元素输出 5. re.finditer(pattern,string,flags=0)搜索字符串，返回一个匹配结果的迭代类型，每个迭代类型是match对象 6. re.sub(pattern,repl,string,cout=0,flags=0)在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 repl:替换匹配字符串的字符串 cout:匹配的最大替换次数 re库的面向对象用法在python中使用正则表达式的时候，re模块内部会做两件事： 编译正则表达式，如果正则表达式本身不合法，会报错 用编译后的正则表达式去匹配字符串 regex = re.compile(pattern,flags=0) 将正则表达式的字符串形式编译成正则表达式对象 pattern:正则表达式的字符串或原生字符串表示 flags:正则表达式使用时的控制标记 compile后生成了regular expression对象，由于该1对象包含了正则表达式，所以调用对应的方法不用给出正则字符串 re库的Match对象 Match对象是一次匹配的结果，包含很多信息 Match对象的属性 属性 说明 .string 待匹配的文本 .re 匹配使用的pattern对象(正则表达式) .pos 正则表达式搜索文本的开始位置 .endpos 正则表达式搜索文本的结束位置 Match对象的方法 方法 说明 .group(0) 获得匹配后的字符串 .start() 匹配字符串在原始字符串的开始位置 .end() 匹配字符串在原始字符串的结束位置 .span() 返回(.start(),.end())一个元组 re库的贪婪匹配和最小匹配re库默认使用贪婪匹配，即匹配最长的子串 最小匹配 ** 最小匹配操作符 ** 操作符 说明 *? 前一个字符0次或者无限次扩展，最小匹配 +? 前一个字符1次或者无限次扩展，最小匹配 ?? 前一个字符0次或1次扩展，最小匹配 {m,n}? 扩展前一个字符m至n次(包含n)，最小匹配 只要输出长度可能不同的，都可以通过在操作符后面加?变成最小匹配 https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000","categories":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/categories/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://dreamer1103.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://dreamer1103.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"定向爬虫-中国大学MOOC-python网络爬虫实例","slug":"定向爬虫-中国大学MOOC-python网络爬虫实例","date":"2018-10-15T15:48:56.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/10/15/定向爬虫-中国大学MOOC-python网络爬虫实例/","link":"","permalink":"https://dreamer1103.github.io/2018/10/15/%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB-%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/","excerpt":"定向爬虫:仅对输入URL进行爬取，不扩展爬取中国大学排名2018","text":"定向爬虫:仅对输入URL进行爬取，不扩展爬取中国大学排名2018 format格式化输出 看下所需信息位置 程序大体框架12345678910111213141516171819202122import requestsfrom bs4 import BeautifulSoupdef getHTMLText(url): return \"\"def fillUnivList(ulist,html): passdef printUnivList(ulist,num): print(\"Suc\"+str(num))def main(): uinfo = [] url = \"\" html = getHTMLText(url) fillUnivList(uinfo,html) printUnivList(uinfo,10)main() getHTMLText()12345678def GetHTMLText(url): #获取网页内容 try: r = requests.get(url) r.raise_for_status() #用于捕获异常 r.encoding = r.apparent_encoding return r.text except: return \"\" fillUnivList()12345678def fillUnivList(ulist, html): # 把网页内容放到数据结构中 soup = BeautifulSoup(html,\"html.parser\") '''一个tr标签存放一所大学的信息''' for tr in soup.find(\"tbody\").children: if isinstance(tr,bs4.element.Tag): #仅仅遍历标签,过滤掉非标签类型的其它信息 tds = tr('td') #将所有的td标签存放到列表tds中，等价于tr.find_all('td')返回一个列表类型 '''由于进行了遍历，使用print打印tds会得到多个列表''' ulist.append([tds[0].string, tds[1].string, tds[3].string])#向ulist中增加所需要的信息 printUnivList()12345def printUnivlist(ulist, num): print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(\"排名\",\"学校\",\"总分\")) for i in range(num): u = ulist[i] print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(u[0],u[1],u[2])) main12345678910111213141516171819202122232425262728293031323334353637import requestsimport bs4 # 用到instancefrom bs4 import BeautifulSoupdef GetHTMLText(url): #获取网页内容 try: r = requests.get(url) r.raise_for_status() #用于捕获异常 r.encoding = r.apparent_encoding return r.text except: return \"\"def fillUnivList(ulist, html): # 把网页内容放到数据结构中 soup = BeautifulSoup(html,\"html.parser\") '''一个tr标签存放一所大学的信息''' for tr in soup.find(\"tbody\").children: if isinstance(tr,bs4.element.Tag): #仅仅遍历标签,过滤掉非标签类型的其它信息 tds = tr('td') #将所有的td标签存放到列表tds中，等价于tr.find_all('td')返回一个列表类型 '''由于进行了遍历，使用print打印tds会得到多个列表''' ulist.append([tds[0].string, tds[1].string, tds[3].string])#向ulist中增加所需要的信息def printUnivlist(ulist, num): print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(\"排名\",\"学校\",\"总分\")) for i in range(num): u = ulist[i] print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(u[0],u[1],u[2]))def main(): uinfo = [] url = \"http://www.zuihaodaxue.cn/zuihaodaxuepaiming2018.html\" html = GetHTMLText(url) fillUnivList(uinfo,html) printUnivlist(uinfo,10)main() 代码优化，使用chr(12288)解决中文对齐问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport bs4 # 用到instancefrom bs4 import BeautifulSoupdef GetHTMLText(url): #获取网页内容 try: r = requests.get(url) r.raise_for_status() #用于捕获异常 r.encoding = r.apparent_encoding return r.text except: return \"\"def fillUnivList(ulist, html): # 把网页内容放到数据结构中 soup = BeautifulSoup(html,\"html.parser\") '''一个tr标签存放一所大学的信息''' for tr in soup.find(\"tbody\").children: if isinstance(tr,bs4.element.Tag): #仅仅遍历标签,过滤掉非标签类型的其它信息 tds = tr('td') #将所有的td标签存放到列表tds中，等价于tr.find_all('td')返回一个列表类型 '''由于进行了遍历，使用print打印tds会得到多个列表''' ulist.append([tds[0].string, tds[1].string, tds[3].string])#向ulist中增加所需要的信息'''def printUnivlist(ulist, num): print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(\"排名\",\"学校\",\"总分\")) for i in range(num): u = ulist[i] print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(u[0],u[1],u[2]))''''''优化输出格式，中文对齐问题,使用chr(12288)表示一个中文空格，utf-8编码'''def printUnivlist(ulist, num): tplt = \"&#123;0:^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:^10&#125;\" #输出模板，&#123;3&#125;使用format函数第三个变量进行填充，即使用中文空格进行填充 print(tplt.format(\"排名\",\"学校\",\"总分\",chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0],u[1],u[2],chr(12288)))def main(): uinfo = [] url = \"http://www.zuihaodaxue.cn/zuihaodaxuepaiming2018.html\" html = GetHTMLText(url) fillUnivList(uinfo,html) printUnivlist(uinfo,10)main()","categories":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://dreamer1103.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Eyes candy","slug":"Eyes-candy","date":"2018-10-15T15:28:16.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/10/15/Eyes-candy/","link":"","permalink":"https://dreamer1103.github.io/2018/10/15/Eyes-candy/","excerpt":"","text":"","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://dreamer1103.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Just relax","slug":"Just-relax","date":"2018-10-13T15:44:56.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/10/13/Just-relax/","link":"","permalink":"https://dreamer1103.github.io/2018/10/13/Just-relax/","excerpt":"","text":"![](https://i.imgur.com/SHZN1xr.jpg)","categories":[],"tags":[{"name":"Astronomy","slug":"Astronomy","permalink":"https://dreamer1103.github.io/tags/Astronomy/"}]},{"title":"工具小整合","slug":"工具小整合","date":"2018-10-03T07:00:06.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/10/03/工具小整合/","link":"","permalink":"https://dreamer1103.github.io/2018/10/03/%E5%B7%A5%E5%85%B7%E5%B0%8F%E6%95%B4%E5%90%88/","excerpt":"","text":"百度文库、知网文章下载https://pan.baidu.com/s/1-BY2B4hBn_3wHgYlXkFLCg 百度云下载提速软件https://pan.baidu.com/s/1EYy5AN9JVv7m42f6NNmvlA 微软PE工具箱https://pan.baidu.com/s/1J1Nud9qTU6jSP6cTpk8Zlg window10数字权利激活工具 github: https://github.com/TGSAN/CMWTAT_Digital_Edition/releases https://github.com/vyvojar/slshim/releases 激活方法参考https://pan.baidu.com/s/1_VqJiuBeCHLyRp5Xcc562wkms激活工具win10下载 Gif制作工具https://pan.baidu.com/s/1Eu_O-7EPSB81cwmR-R1zvw提取码:q51n 录屏软件https://pan.baidu.com/s/1VsN5XClhZiRCqUyxbTJ_tg提取码:vlrb CamStudio汉化版提取码:kckg","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://dreamer1103.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"简单爬虫","slug":"简单爬虫","date":"2018-09-28T17:17:32.000Z","updated":"2018-09-29T15:19:00.000Z","comments":true,"path":"2018/09/29/简单爬虫/","link":"","permalink":"https://dreamer1103.github.io/2018/09/29/%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/","excerpt":"Requests库入门http://www.python-requests.org/en/master/requests Requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基本方法 requests.get() 获取HTML网面的方法 requests.head() 获取HTML网页头部信息的方法 requests.post() 向HTML网页提交POST请求的方法 requests.put() 向HTML页面提交PUT请求的方法 requests.patch() 向HTML网页提交局部修改请求 requests.delete() 向HTML网页提交删除请求","text":"Requests库入门http://www.python-requests.org/en/master/requests Requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基本方法 requests.get() 获取HTML网面的方法 requests.head() 获取HTML网页头部信息的方法 requests.post() 向HTML网页提交POST请求的方法 requests.put() 向HTML页面提交PUT请求的方法 requests.patch() 向HTML网页提交局部修改请求 requests.delete() 向HTML网页提交删除请求 Requests库的get()方法requests.get(url,params=None,**kwargs) url：拟获取页面的url链接 params：url中的额外参数，字典或字节流格式，可选 **kwargs：12个控制访问的参数 r = requests.get(url) r为一个包含服务器资源的Response对象(即为requests.get()返回内容) get()方法和url构造了一个向服务器请求资源的Request对象 Response对象Response对象包含服务器反回的所有信息，也包含请求的Request信息 Response对象的属性 属性 说明 r.stats_code HTTP请求的返回状态，200表示连接成功 r.txt HTTP响应的字符串形式 r.encoding 从HTTP header中猜测的响应方式的内容编码 r.apparent_enconding 从内容中分析出的响应内容编码方式（备选编码方式） r.content HTTP响应内容编码的二进制形式 r.encoding:如果charset不存在，则默认编码为ISO-8859-1，r.text根据r.encoding显示网页内容 r.apparent_encoding：根据网页内容分析出的编码方式 理解Response异常r.raise_for_status()如果不是200，产生异常requests.HTTPError异常 1r.raise_for_status()在方法内部判断r.statu_code是否等于200，不需要增加额外的if语句，该语句便于try-except进行异常处理 Requests库的异常 异常 说明 requests.ConnectonError 网路连接错误异常 requests.HTTPError HTTP错误异常 requests.URLRequire URL缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器异常 requests.Timeout 请求URL超时，产生超时异常 python爬取网页代码通用框架12345678910111213141516import requests#import timedef getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status()#如果状态不是200，产生HTTPError异常 #print(r.status_code) r.encoding = r.apparent_encoding return r.text except: return \"产生异常\"if __name__ == '__main__': url = \"http://www.baidu.com\" print(getHTMLText(url)) Requests库的request()方法requests.request(method, url, **kwargs) method: 请求方式，对应get/put/delete等7种 url:拟获取页面的url链接 **kwargs: 控制访问的参数 kwargs:控制访问参数，（可选）12345678910111213params：字典或字节序列，作为参数增加到URL中data：字典、字节序列或文章对象，作为Request的内容json：Json格式的数据headers：HTTP定制头cookies：字典或CookieJar，Request中的cookieauth：元组，支持HTTP认证功能file：字典类型，传输文件timeout：设置超时时间，单位为秒proxies：字典类型，设定访问代理服务器，可以增加登录认证allow_redirects：True&#x2F;False，默认为True，重定向开关strem：True&#x2F;False，默认为True，获取页面立即下载开关verify：True&#x2F;False，默认为True,认证SSl证书开关cert：本地SSL证书","categories":[{"name":"Python","slug":"Python","permalink":"https://dreamer1103.github.io/categories/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://dreamer1103.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"Requests","slug":"Requests","permalink":"https://dreamer1103.github.io/tags/Requests/"}]},{"title":"博客搭建历程（4）","slug":"博客搭建历程（4）","date":"2018-09-27T08:35:56.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/09/27/博客搭建历程（4）/","link":"","permalink":"https://dreamer1103.github.io/2018/09/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B%EF%BC%884%EF%BC%89/","excerpt":"博客评论系统的选择其他评论系统参考经过一波折腾，最终选择了Valine我喜欢它的匿名评论，23333！！！ 参考教程 作者的博客 Valine文档 https://github.com/litten/hexo-theme-yilia/pull/646 https://www.xxwhite.com/2017/Valine.html https://panjunwen.com/diy-a-comment-system/","text":"博客评论系统的选择其他评论系统参考经过一波折腾，最终选择了Valine我喜欢它的匿名评论，23333！！！ 参考教程 作者的博客 Valine文档 https://github.com/litten/hexo-theme-yilia/pull/646 https://www.xxwhite.com/2017/Valine.html https://panjunwen.com/diy-a-comment-system/ 安装过程简记 注册Leancloud 创建应用 获取appid和appkey 设置安全域名 部署云引擎 参考设置好环境变量 yilia主题修改1、修改themes\\yilia\\_config.ymlhttps://github.com/litten/hexo-theme-yilia/pull/646 12345678910#6、Valine https://valine.js.orgvaline: enable: true appid: #LeanCloud的appId appkey: #Leancloud的appKey verify: false #验证码 notifi: false #评论回复提醒 avatar: ' '#评论列表头像样式 placeholder: Just go go #评论占位框 pageSize: 15 #评论分页 2、修改themes\\yilia\\layout\\_partial\\article.ejs我是在尾部位添加的 123456789&lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt; &lt;section id=\"comments\" style=\"margin:10px;padding:10px;background:#fff;\"&gt; &lt;%- partial('post/valine', &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;/section&gt; &lt;% &#125; %&gt; 在themes\\yilia\\layout\\_partial\\post下新建个·valine.ejs·文件添加如下代码 123456789101112131415161718&lt;div id=\"vcomment\" class=\"comment\"&gt;&lt;/div&gt; &lt;script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/valine/dist/Valine.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var notify = '&lt;%= theme.valine.notify %&gt;' == true ? true : false; var verify = '&lt;%= theme.valine.verify %&gt;' == true ? true : false; window.onload = function() &#123; new Valine(&#123; el: '#vcomment', notify: notify, verify: verify, app_id: \"&lt;%= theme.valine.appid %&gt;\", app_key: \"&lt;%= theme.valine.appkey %&gt;\", placeholder: \"&lt;%= theme.valine.placeholder %&gt;\", avatar:\"&lt;%= theme.valine.avatar %&gt;\" &#125;); &#125;&lt;/script&gt; 测试下效果hexo g hexo s预览 没问题就部署到github吧 hexo d -g 定时器添加https://github.com/zhaojun1998/Valine-Admin/issues/1","categories":[{"name":"blog","slug":"blog","permalink":"https://dreamer1103.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://dreamer1103.github.io/tags/hexo/"}]},{"title":"博客搭建历程（3）","slug":"博客搭建历程（3）","date":"2018-09-26T12:11:17.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/09/26/博客搭建历程（3）/","link":"","permalink":"https://dreamer1103.github.io/2018/09/26/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B%EF%BC%883%EF%BC%89/","excerpt":"hexo生成工程文件介绍 hexo插件 主题yilia 默认目录结构具体参考","text":"hexo生成工程文件介绍 hexo插件 主题yilia 默认目录结构具体参考 |--.deploy |--public |--scaffolds |--source |--themes |--_config.yml |--package.json .deploy ：部署到GitHub上的内容目录 public：输出的静态网页内容目录 scaffolds：layout模板文件目录 source：文件源码目录 themes：主题文件目录 —config.yml：全局配置文件 package.json：应用程序数据 给主题yilia配置干货一、腾讯公益404公益404 hexo new page 404 #新建一个页面 1234567891011#在生成的index.md文件下添加以下代码&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;]\\&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1hexo d -g#直接部署到GitHub 参考 二、制作个网站ico戳这里 也可以不弄，直接用 把你的网站ico放在public\\img即可修改theme\\_config.yml 三、使用网站访问量统计(使用友盟)效果如下 注册账号友盟官网 获取代码 在hemes\\yilia\\layout\\_partial\\footer.ejs挑个位置放 12hexo ghexo s 看下效果 hexo d #部署到 github 若不想用CNZZ参考","categories":[{"name":"blog","slug":"blog","permalink":"https://dreamer1103.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://dreamer1103.github.io/tags/hexo/"}]},{"title":"博客搭建历程（2）","slug":"博客搭建历程（2）","date":"2018-09-25T15:31:27.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/09/25/博客搭建历程（2）/","link":"","permalink":"https://dreamer1103.github.io/2018/09/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B%EF%BC%882%EF%BC%89/","excerpt":"一、使用hexo deploy部署博客到Github 使用参考 ** 先安装个扩展$ npm install hexo-deployer-git --save ** 1.修改博客根目录下的_config_yml文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:yeshan333/yeshan333.github.io.git # 这个可到Github仓库拿 branch: master","text":"一、使用hexo deploy部署博客到Github 使用参考 ** 先安装个扩展$ npm install hexo-deployer-git --save ** 1.修改博客根目录下的_config_yml文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:yeshan333/yeshan333.github.io.git # 这个可到Github仓库拿 branch: master 2.部署到GitHub repo生成ssh keys1ssh-keygen -t rsa -C \"邮件地址@youremail.com\" #生成新的key文件，邮箱地址填注册Github时用的 将生成的ssh keys添加到Github的deploy keys中 复制key ** 这里用到.ssh目录下，id_rsa.pub文件中的那串key** 到GitHub的yourname.hithub.io仓库添加那串key到deploy keys中 测试一下是否添加成功了: 1ssh -T git@github.com 部署博客 先配好git用户信息 12git config --global user.name \"你的名字\" # github用户名git config --global user.email \"邮箱@邮箱.com\" # github邮箱 部署博客到仓库 12hexo g # 生成静态文件hexo d # 部署到远程仓库 访问https://yourname.github.io查看结果 ** 到此，整个博客搭建完成了 ** 以下是写的是博客主题的更换，主题可以自己写，也可以使用别人写的，可去这里https://hexo.io/themes/找喜欢的主题，如果使用的是别人的主题，需要阅读主题使用文档进行相关配置。 二、Hexo主题设置 更换主题 cd进themes目录 12cd themesgit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 对根目录下的config_yml文件进行修改 12cd themes&#x2F;yiliagit pull #更新主题 预览新主题 123hexo clean # 清楚缓存，删除public目录hexo g # 生成新的博客静态文件hexo s 去http://localhost:4000预览，没毛病就hexo d部署到远程仓库。","categories":[{"name":"blog","slug":"blog","permalink":"https://dreamer1103.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://dreamer1103.github.io/tags/hexo/"}]},{"title":"博客搭建历程（1）","slug":"博客搭建历程（1）","date":"2018-09-25T14:40:31.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/09/25/博客搭建历程（1）/","link":"","permalink":"https://dreamer1103.github.io/2018/09/25/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B%EF%BC%881%EF%BC%89/","excerpt":"我为什么要搭建自己的博客:人嘛!总会有迷茫的时候。无聊了就搭建一个博客玩玩。借此思考下人生戳这里先洗下脑 [BetterExplained]为什么你应该（从现在开始就）写博客 使用Hexo+GitHub Pages搭建属于自己的博客依赖 安装Node.js 安装git 一个GitHub账号 hexo全家桶","text":"我为什么要搭建自己的博客:人嘛!总会有迷茫的时候。无聊了就搭建一个博客玩玩。借此思考下人生戳这里先洗下脑 [BetterExplained]为什么你应该（从现在开始就）写博客 使用Hexo+GitHub Pages搭建属于自己的博客依赖 安装Node.js 安装git 一个GitHub账号 hexo全家桶 一、Node.js安装参考Node.js官网 nodejs版本越高越好，不然后面安装hexo时会出现问题，Hexo官网给的建议是6.9版本以上 官网windows 64bit 下载(v10.16.0) 二、git的安装参考安装需根据自己的实际情况，在cmd使用git --version指令可以查看安装的版本 windows 64 bit 下载（v2.19.0） 三、使用Github Pages 注册Github账号 创建一个repository，用于存放博客站点文件 开启Github Page 1、创建一个repository 仓库命名方式须注意下，这样命名会开启githubpage服务，代码仓库命名方式随意，如果以用户名+github.io的形式命名，会自动开启Github Pages服务，否则需要自己在仓库的设置那里手动开启GIthub Pages服务。 Github Pages 是 github 公司提供的免费的静态网站托管服务，用起来方便而且功能强大，不仅没有空间限制(为免费用户提供了500M空间)，还可以绑定自己的域名，1GB空间限制（个人博客够用了），每月带宽限制100GB，自由绑定自己的域名。 2、开启GitHub PagesGitHub Pages官方介绍，Github的中文官方文档已推出https://help.github.com/cn/articles/what-is-github-pages(2019年7月11日更新) 点击choose a theme选完主题后即可到https://yourname.github.io/访问自己的个人主页了，yourname记得替换成你的用户名。 接下来需要使用Hexo在本地创建好博客，再将博客文件上传到刚刚创建的仓库。 四、Hexo配置 Hexo是一个静态站点生成器，如果想深入了解Hexo可以去Hexo的官网看看。https://hexo.io/zh-cn/docs/ 在本地搭建博客1.安装hexo插件套装以下两条命令直接打开windows cmd执行即可，用git bash执行也行 12# 安装hexo命令行工具npm install hexo-cli -g 安装hexo包到全局node_modules中，修改package.json文件，将模块名和版本号添加到dependencies部分npm install hexo –save 2.初始化hexo 这里需要新建个目录用于存放本地的博客文件 往后的命令均需要在此目录下执行，可用cd命令进入目录中执行往后的命令 1hexo init # 初始化目录，生成相关文件 目录中生成的文件如下 123456789101112.├── node_modules # 存放博客依赖的npm packages├── scaffolds # 存放生成博客文章、博客页面、草稿的模板目录├ ├── draft.md├ ├── page.md├ └── post.md├── source├ └── posts # 用于存放博客文章├── _config.yml # 博客全局配置文件├── .gitignore├── package.json # 记录当前目录下实际安装的各个npm package的具体来源和版本号└── package-lock.json # 存放锁定安装时的包的版本号，此文件一般会上传到git 12hexo g # 生成静态页面hexo s # 部署到本地服务器http://localhost:4000/ 预览效果http://localhost:4000/ 到这里本地的博客搭建完了，接下来就是将博客上传到刚刚创建的Github仓库，上传后就可以使用外网访问了 博客搭建历程（2） 博客搭建参考教程推荐 csdn w3cschool 博客园 思否","categories":[{"name":"blog","slug":"blog","permalink":"https://dreamer1103.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://dreamer1103.github.io/tags/hexo/"}]},{"title":"hello my first blog in here ！","slug":"hello-my-first-blog-in-here-！","date":"2018-09-19T15:14:15.000Z","updated":"2020-03-14T15:25:59.000Z","comments":true,"path":"2018/09/19/hello-my-first-blog-in-here-！/","link":"","permalink":"https://dreamer1103.github.io/2018/09/19/hello-my-first-blog-in-here-%EF%BC%81/","excerpt":"","text":"New Start","categories":[],"tags":[]}]}